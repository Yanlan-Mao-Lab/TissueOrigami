
#include "Simulation.h"
#include "Prism.h"
#include <string.h>

using namespace std;

Simulation::Simulation(){
	currElementId = 0;
	SystemCentre[0]=0.0; SystemCentre[1]=0.0; SystemCentre[2]=0.0;
	time =0.0;
};

Simulation::~Simulation(){
};

void Simulation::initiateSystem(){
	int MeshType = 2;
	int Row = 10;
	int Column = Row-2;
	float SideLength=1.0;
	float zHeight = 2.0;

	if (MeshType == 1){
		initiateMesh(MeshType);
	}
	else if (MeshType == 2){
		initiateMesh(MeshType, Row, Column,  SideLength,  zHeight);
	}
	initiateSystemForces();
	calculateSystemCentre();
	assignPhysicalParameters();
	CalculateStiffnessMatrices();
}

void Simulation::initiateMesh(int MeshType){
	if (MeshType == 1 ){
		initiateSinglePrismNodes();
		initiateSinglePrismElement();
	}
	if (MeshType == 2){
		cerr<<"Error: Too few arguments for mesh by dimensions"<<endl;
	}
	else if ( MeshType == 3 || MeshType ==4 ){
		cerr<<"Error: Wrong set of arguments  for mesh triangulation"<<endl;
	}
	else {
		cerr<<"Error: Mesh Type not recognised"<<endl;
	}
}

void Simulation::initiateMesh(int MeshType, int Row, int Column, float SideLength, float zHeight){
	if ( MeshType == 1 ){
		cerr<<"Error: Too many arguments for a single element system"<<endl;
	}
	if ( MeshType == 2){
		initiateNodesByRowAndColumn(Row,Column,SideLength,zHeight);
		initiateElementsByRowAndColumn(Row,Column);
	}
	else if ( MeshType == 3 ){
		cerr<<"Error: Wrong set of arguments  for mesh triangulation"<<endl;
	}
	else if ( MeshType ==4 ){
			cerr<<"Error: Too many arguments for reading the mesh from file"<<endl;
	}
	else {
		cerr<<"Error: Mesh Type not recognised"<<endl;
	}
}

void Simulation::initiateMesh(int MeshType, string inputtype, float SideLength, float zHeight ){
	if ( MeshType == 1 ){
		cerr<<"Error: Too many arguments for a single element system"<<endl;
	}
	if ( MeshType == 2){
		cerr<<"Error: Too few arguments for mesh by dimensions"<<endl;
	}
	else if ( MeshType == 3 ){
		//this will be inputting circumference of the tissue, and the sidelength and z-height
		//generate mesh by triangulation
		float a = zHeight;float b = SideLength;
	}
	else if ( MeshType ==4 ){
		cerr<<"Error: Too many arguments for reading the mesh from file"<<endl;
		//this will be reading full mesh data
		//read mesh data from file
	}
	else {
		cerr<<"Error: Mesh Type not recognised"<<endl;
	}
}

void Simulation::initiateMesh(int MeshType, string inputtype ){
	if ( MeshType == 1 ){
		cerr<<"Error: Too many arguments for a single element system"<<endl;
	}
	if ( MeshType == 2){
		cerr<<"Error: Too few arguments for mesh by dimensions"<<endl;
	}
	else if ( MeshType == 3 ){
		cerr<<"Error: Wrong set of arguments  for mesh triangulation"<<endl;
	}
	else if ( MeshType ==4 ){
		cerr<<"Error: Too many arguments for reading the mesh from file"<<endl;
		//this will be reading full mesh data
		//read mesh data from file
	}
	else {
		cerr<<"Error: Mesh Type not recognised"<<endl;
	}
}

void Simulation::CalculateStiffnessMatrices(){
	for (int i=0; i<Elements.size();++i){
		Elements[i]->calculateReferenceStiffnessMatrix();
	}
}

void Simulation::fixAllD(int i){
	for (int j =0 ; j<Nodes[i]->nDim; ++j){
		Nodes[i]->FixedPos[j]=true;
	}
}

void Simulation::fixZ(int i){
	if(Nodes[i]->nDim>2){
		Nodes[i]->FixedPos[2]=true;
	}
	else{
		cerr<<"ERROR: Node : "<<i<<" does not have z-dimension"<<endl;
	}
}

void Simulation::zeroForcesOnNode(int i){
	double ForceBalance[3];
	ForceBalance[0] = SystemForces[i][0];
	ForceBalance[1] = SystemForces[i][1];
	ForceBalance[2] = SystemForces[i][2];
	int n = Nodes.size();
	for (int i=0;i<n;++i){
		SystemForces[i][0]-=ForceBalance[0];
		SystemForces[i][1]-=ForceBalance[1];
		SystemForces[i][2]-=ForceBalance[2];
	}
}

void Simulation::initiateSystemForces(){
	const int n = Nodes.size();
	SystemForces = new double*[n];
	for (int i=0;i<n;++i){
		SystemForces[i] = new double[3];
		SystemForces[i][0]=0.0;
		SystemForces[i][1]=0.0;
		SystemForces[i][2]=0.0;
		//cout<<"systemforces[i][j]: "<<SystemForces[i][0]<<" "<<SystemForces[i][0]<<" "<<SystemForces[i][0]<<endl;
	}
}

void Simulation::initiateSinglePrismNodes(){
	double *pos = new double[3];
	Node* tmp_nd;
	pos[0]=0;pos[1]=1;pos[2]=0;
	tmp_nd = new Node(0, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=1;pos[1]=0;pos[2]=0;
	tmp_nd = new Node(1, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=0;pos[1]=0;pos[2]=0;
	tmp_nd = new Node(2, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=0;pos[1]=1;pos[2]=1;
	tmp_nd = new Node(3, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=1;pos[1]=0;pos[2]=1;
	tmp_nd = new Node(4, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=0;pos[1]=0;pos[2]=1;
	tmp_nd = new Node(5, 3, pos);
	Nodes.push_back(tmp_nd);
}

void Simulation::initiateSinglePrismElement(){
	int* NodeIds;
	NodeIds = new int[6];
	for (int i = 0; i < 6 ; i++){
		NodeIds[i]=i;
	}
	Prism* PrismPnt01;
	PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
	Elements.push_back(PrismPnt01);
	currElementId++;
	fixZ(0);
	fixZ(1);
	fixZ(2);
}

void Simulation::initiateNodesByRowAndColumn(int Row, int Column, float SideLength, float zHeight){
	//The height of the equilateral triangle with side length: SideLength
	double sqrt3 = 1.7321;
	float h = sqrt3/2*SideLength;
	vector <double> xPos, yPos;
	vector <int> NodesToFix;
	for (int ColCount = 0; ColCount < Column+1; ++ColCount){
		double CurrY = ColCount*h;
		int CurrRowNum = Row + 1 - ColCount;
		double RowOffset = 0.5*SideLength*ColCount;
		for ( int RowCount = 1; RowCount<CurrRowNum+1; ++RowCount){
			double CurrX = RowOffset + RowCount * SideLength;
			xPos.push_back(CurrX);
			yPos.push_back(CurrY);
			if (RowCount ==1 || RowCount == CurrRowNum || ColCount == Column){
				NodesToFix.push_back(xPos.size()-1);
			}
		}
		if (ColCount>0){
			CurrY = (-1.0)*CurrY;
			for ( int RowCount = 1; RowCount<CurrRowNum+1; ++RowCount){
				double CurrX = RowOffset + RowCount * SideLength;
				xPos.push_back(CurrX);
				yPos.push_back(CurrY);
				if (RowCount ==1 || RowCount == CurrRowNum || ColCount == Column){
					NodesToFix.push_back(xPos.size()-1);
				}
			}
		}
	}
	int n =  xPos.size();
	Node* tmp_nd;
	double* pos = new double[3];
	//Adding the lower level of nodes:
	for (int i =0; i< n; ++i){
		pos[0] = xPos[i];
		pos[1] = yPos[i];
		pos[2] = 0.0;
		tmp_nd = new Node(i, 3, pos);
		Nodes.push_back(tmp_nd);
	}
	//Adding the upper level:
	for (int i =0; i< n; ++i){
		pos[0] = xPos[i];
		pos[1] = yPos[i];
		pos[2] = zHeight;
		tmp_nd = new Node(n+i, 3, pos);
		Nodes.push_back(tmp_nd);
	}
	for (int i=0; i<NodesToFix.size(); ++i){
		fixZ(NodesToFix[i]);
		//fixAllD(NodesToFix[i]);
	}
}

void Simulation::initiateElementsByRowAndColumn(int Row, int Column){
	int xinit1 = 0;
	int xinit2 = xinit1+Row+1;
	int xinit3 = 0;
	int xinit4 = xinit1+2*(Row+1)-1;
	int n = Nodes.size()/2.0;

	for (int ColCount = 0; ColCount < Column; ++ColCount){
		int CurrRowNum = Row + 1 - ColCount;
		for (int RowCount = 0; RowCount<CurrRowNum-1; ++RowCount ){
			int* NodeIds;
			NodeIds = new int[6];

			NodeIds[0] = xinit1+RowCount;
			NodeIds[1] = xinit1+RowCount+1;
			NodeIds[2] = xinit2+RowCount;
			NodeIds[3] = NodeIds[0] + n;
			NodeIds[4] = NodeIds[1] + n;
			NodeIds[5] = NodeIds[2] + n;
			Prism* PrismPnt01;
			PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
			Elements.push_back(PrismPnt01);
			currElementId++;

			NodeIds[0] = xinit3+RowCount;
			NodeIds[1] = xinit4+RowCount;
			NodeIds[2] = xinit3+RowCount+1;
			NodeIds[3] = NodeIds[0] + n;
			NodeIds[4] = NodeIds[1] + n;
			NodeIds[5] = NodeIds[2] + n;
			PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
			Elements.push_back(PrismPnt01);
			currElementId++;
		}
		for (int RowCount = 0; RowCount<CurrRowNum-2; ++RowCount ){
			int* NodeIds;
			NodeIds = new int[6];

			NodeIds[0] = xinit2+RowCount;
			NodeIds[1] = xinit1+RowCount+1;
			NodeIds[2] = xinit2+RowCount+1;
			NodeIds[3] = NodeIds[0] + n;
			NodeIds[4] = NodeIds[1] + n;
			NodeIds[5] = NodeIds[2] + n;
			Prism* PrismPnt01;
			PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
			Elements.push_back(PrismPnt01);
			currElementId++;

			NodeIds[0] = xinit4+RowCount;
			NodeIds[1] = xinit4+RowCount+1;
			NodeIds[2] = xinit3+RowCount+1;
			NodeIds[3] = NodeIds[0] + n;
			NodeIds[4] = NodeIds[1] + n;
			NodeIds[5] = NodeIds[2] + n;
			PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
			Elements.push_back(PrismPnt01);
			currElementId++;

		}
		xinit1 = xinit2;
		xinit2 = xinit4 + CurrRowNum-1;
		xinit3 = xinit4;
		xinit4 = xinit2 + CurrRowNum-2;
	}
	cout<<"finalised element initiation"<<endl;
}

void Simulation::calculateSystemCentre(){
	int n = Nodes.size();
	for (int i = 0; i< n; ++i){
		for (int j =0; j<Nodes[i]->nDim; ++j){
			SystemCentre[j] += Nodes[i]->Position[j];
		}
	}
	SystemCentre[0]= SystemCentre[0]/n;
	SystemCentre[1]= SystemCentre[1]/n;
	SystemCentre[2]= SystemCentre[2]/n;
}

void Simulation::assignPhysicalParameters(){
	double E = 10.0, v= 0.2;
	double ApicalVisc = 10.0, BasalVisc=200.0;
	for (int i=0; i<Elements.size();++i){
		Elements[i]->setElasticProperties(E,v);
		Elements[i]->setViscosity(ApicalVisc, BasalVisc, Nodes);
	}
}

void Simulation::RunOneStep(){
	double dt = 0.01;
	cout<<"time: "<<time<<endl;
	//if (time == 0.0){
	//	growSystem(2);
	//}
	//size doubles every half hour, then in one time step: 2.0 / (30min) * dt
	growSystem(2.0/(30.0*60.0)*dt);
	const int n = Nodes.size();
	const int dim = 3;
	//memset(SystemForces,0.0,sizeof(SystemForces[0][0])*n*dim);
	for (int i=0;i<n;++i){
		for (int j=0;j<dim;++j){
			SystemForces[i][j]=0.0;
		}
	}
	//aligning the centres:
	for (int i=0;i<Elements.size();++i){
		Elements[i]->alignReference();
		Elements[i]->calculateForces(1,SystemForces, Nodes);
	}
	//Fixing Node 0 in space:
	//zeroForcesOnNode(0);

	//Update Node positions:
	for (int i=0;i<n;++i){
		for (int j=0; j<Nodes[i]->nDim; ++j){
			Nodes[i]->Velocity[j] = SystemForces[i][j]/Nodes[i]->Viscosity;
			Nodes[i]->Position[j] += Nodes[i]->Velocity[j]*dt;
		}
	}
	for (int i=0;i<Elements.size();++i){
		Elements[i]->updatePositions(Nodes);
	}
	time +=dt;
}

void Simulation::growSystem(float scale){
	cout<<"growing the system with scale factor: "<<scale<<endl;
	double range  = 20;
	double range2 = range*range;
	int  n = Elements.size();
	for ( int i = 0; i < n; ++i ){
		double* centre = new double[3];
		centre = Elements[i]->getCentre();
		double d[3] = {SystemCentre[0]- centre[0], SystemCentre[1]- centre[1], SystemCentre[2]- centre[2]};
		double dmag2 = d[0]*d[0] +  d[1]*d[1] + d[2]*d[2];
		if (dmag2 < range2){
			double dmag = pow(dmag2,0.5);
			double S = 1 + (scale -1.0)*(range-dmag)/range;
			Elements[i]->growShape(S);
		}
	}
}
