
#include "Simulation.h"
#include "Prism.h"
#include <string.h>

using namespace std;

Simulation::Simulation(){
	currElementId = 0;
	ModInp = new ModelInputObject();
	SystemCentre[0]=0.0; SystemCentre[1]=0.0; SystemCentre[2]=0.0;
	timestep = 0;
	reachedEndOfSaveFile = false;
	setDefaultParameters();
};

Simulation::~Simulation(){
	delete ModInp;
	int n = Nodes.size();
	for (int i=0;i<n;++i){
		delete[] SystemForces[i];
	}
	delete[] SystemForces;
	while(!Elements.empty()){
		ShapeBase* tmp_pt;
		tmp_pt = Elements.back();
		Elements.pop_back();
		delete tmp_pt;
	}
	while(!Nodes.empty()){
		Node* tmp_pt;
		tmp_pt = Nodes.back();
		Nodes.pop_back();
		delete tmp_pt;
	}
};

void Simulation::setDefaultParameters(){
	dt = 0.01;				//sec
	SimLength = 10.0/dt; 	//timesteps wothr 10 sec of simulation
	saveImages = false;		//do not save simulation images by default
	saveData = false;		//do not save simulation data by default
	imageSaveInterval = 60.0/dt;	//save images every minute
	dataSaveInterval  = 60.0/dt;	//save data every minute
	saveDirectory = "Not-Set";	//the directory to save the images and data points
	saveFileToDisplayString  = "Not-Set"; //the file whcih will be read and displayed - no simulation
	E = 10.0;
	poisson = 0.3;
	ApicalVisc = 10.0;
	BasalVisc = 100.0;
	memset(noiseOnPysProp,0,4*sizeof(int));
	// The default input is a calculated mesh of width 4 elements, each element being 2.0 unit high
	// and having 1.0 unit sides of the triangles.
	MeshType = 2;
	Row = 4;
	Column = Row-2;
	SideLength=1.0;
	zHeight = 2.0;
	nGrowthFunctions = 0;
}

bool Simulation::readExecutableInputs(int argc, char **argv){
	int i = 1;
	bool Success = true;
	while(i<argc){
		const char *inptype = argv[i];
		if (string(inptype) == "-mode"){
			Success = readModeOfSim(i, argc, argv);
		}
		else if (string(inptype) == "-i"){
			Success = readParameters(i, argc, argv);
		}
		else if (string(inptype) == "-od"){
			Success = readOutputDirectory(i, argc, argv);
		}
		else if (string(inptype) == "-dInput"){
			Success = readSaveFileToDisplay(i, argc, argv);
		}
		else {
			cerr<<"Please enter a valid option key: {-mode,-i, -od}, current string: "<<inptype<<endl;
			return false;
		}
		i++;
		if (!Success){
			return Success;
		}
	}
	Success = checkInputConsistency();
	return Success;
}

bool Simulation::readModeOfSim(int& i, int argc, char **argv){
	i++;
	if (i > argc){
		cerr<<" input the mode of simulation: {DisplaySave, SimulationOnTheGo, Default}"<<endl;
		return false;
	}
	const char* inpstring = argv[i];
	if (string(inpstring) == "DisplaySave"){
		DisplaySave = true;
		return true;
	}
	else if (string(inpstring) == "SimulationOnTheGo" || string(inpstring) == "Default"){
		DisplaySave = false;
		return true;
	}
	else{
		cerr<<"Please provide input mode: -mode {DisplaySave, SimulationOnTheGo, Default}";
		return false;
	}
}

bool Simulation::readParameters(int& i, int argc, char **argv){
	i++;
	if (i > argc){
		cerr<<" input the model input file directory"<<endl;
		return false;
	}
	cerr<<"Reading parameter input file"<<endl;
	const char* inpstring = argv[i];
	ModInp->Sim=this;
	ModInp->parameterFileName =  inpstring;
	cerr<<" Reading parameters from file: "<<ModInp->parameterFileName<<endl;
	bool Success = ModInp->readParameters();
	if (!Success){
		return Success;
	}
	return true;
}

bool Simulation::readSaveFileToDisplay(int& i, int argc, char **argv){
	i++;
	if (i > argc){
		cerr<<" input the save file name to be displayed"<<endl;
		return false;
	}
	const char* inpstring = argv[i];
	saveFileToDisplayString = string(inpstring);
	return true;
}

bool Simulation::readOutputDirectory(int& i, int argc, char **argv){
	i++;
	if (i > argc){
		cerr<<" input the save directory"<<endl;
		return false;
	}
	const char* inpstring = argv[i];
	//This will set the save directory, but will not change the safe file boolean.
	//If your model input file states no saving, then the error and output files
	//will be directed into this directory, but the frame saving will not be toggled
	saveDirectory= string(inpstring);
	return true;

}

bool Simulation::checkInputConsistency(){
	if (saveData || saveImages){
		if (saveDirectory == "Not-Set"){
			cerr <<"Modelinput file requires saving, please provide output directory, using -od tag"<<endl;
			return false;
		}
	}
	if (DisplaySave){
		if (saveFileToDisplayString == "Not-Set"){
			cerr <<"The mode is set to display from save, please provide an input file, using -dInput"<<endl;
			return false;
		}
	}
	return true;
}

bool Simulation::initiateSystem(){
	bool Success = openFiles();
	if (!Success){
		return Success;
	}

	if (MeshType == 1){
		initiateMesh(MeshType);
	}
	else if (MeshType == 2){
		initiateMesh(MeshType, Row, Column,  SideLength,  zHeight);
	}
	initiateSystemForces();
	calculateSystemCentre();
	assignPhysicalParameters();
	CalculateStiffnessMatrices();
	return Success;
}

bool Simulation::openFiles(){
	bool Success;
	if (saveData){
		string saveFileString = saveDirectory +"/FrameSave";
		const char* name_saveFile = saveFileString.c_str();
		dataSaveFile.open(name_saveFile, ofstream::out);
		if (dataSaveFile.good() && dataSaveFile.is_open()){
			Success = true;
		}
		else{
			cerr<<"could not open file: "<<name_saveFile<<endl;
			Success = false;
		}
	}
	string outputFileString;
	if (saveDirectory == "Not-Set"){
		cerr<<"Output directory is not set, outputting on Out file in current directory"<<endl;
		outputFileString = "./Out";
	}
	else {
		outputFileString = saveDirectory +"/Out";
	}
	const char* name_outputFile = outputFileString.c_str();
	outputFile.open(name_outputFile, ofstream::out);
	if (outputFile.good() && outputFile.is_open()){
		Success = true;
	}
	else{
		cerr<<"could not open file: "<<name_outputFile<<endl;
		Success = false;
	}
	return Success;
}

bool Simulation::initiateSavedSystem(){
	const char* name_saveFileToDisplay = saveFileToDisplayString.c_str();;
	saveFileToDisplay.open(name_saveFileToDisplay, ifstream::in);
	if (!(saveFileToDisplay.good() && saveFileToDisplay.is_open())){
		cerr<<"Cannot open the save file to display: "<<name_saveFileToDisplay<<endl;
		return false;
	}
	string currline;
	//skipping the header:
	getline(saveFileToDisplay,currline);
	initiateNodesFromSave();
	initiateElementsFromSave();
	//skipping the footer:
	getline(saveFileToDisplay,currline);
	return true;
}

void Simulation::initiateNodesFromSave(){
	int n;
	saveFileToDisplay >> n;
	Node* tmp_nd;
	for (int i=0; i<n; ++i){
		double* pos = new double[3];
		saveFileToDisplay >> pos[0];
		saveFileToDisplay >> pos[1];
		saveFileToDisplay >> pos[2];
		tmp_nd = new Node(i, 3, pos);
		Nodes.push_back(tmp_nd);
		delete[] pos;
	}
}

void Simulation::initiateElementsFromSave(){
	int n;
	saveFileToDisplay >> n;
	for (int i=0; i<n; ++i){
		int shapeType;
		saveFileToDisplay >> shapeType;
		if (shapeType == 1){
			initiatePrismFromSave();
		}
		else{
			cerr<<"Error in shape type, corrupt save file!"<<endl;
		}
	}
}

void Simulation::initiatePrismFromSave(){
	int* NodeIds;
	NodeIds = new int[6];
	for (int i =0 ;i<6; ++i){
		saveFileToDisplay >> NodeIds[i];
	}
	Prism* PrismPnt01;
	PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
	PrismPnt01->updateReferencePositionMatrixFromSave(saveFileToDisplay);
	Elements.push_back(PrismPnt01);
	currElementId++;
	delete[] NodeIds;
}

void Simulation::updateOneStepFromSave(){
	cout<<"Updating step from save:"<<endl;
	string currline;
	//skipping the header:
	getline(saveFileToDisplay,currline);
	updateNodeNumberFromSave();
	updateElementNumberFromSave();
	updateNodePositionsFromSave();
	int n = Elements.size();
	for (int i=0; i<n; ++i){
		Elements[i]->updatePositions(Nodes);
		Elements[i]->updateReferencePositionMatrixFromSave(saveFileToDisplay);
	}
	timestep++;
	//skipping the footer:
	getline(saveFileToDisplay,currline);
	if(saveFileToDisplay.eof()){
		reachedEndOfSaveFile = true;
	}
	timestep++;
}

int  Simulation::updateNodeNumberFromSave(){
	int n;
	saveFileToDisplay >> n;
	int currNodeNumber = Nodes.size();
	if (n>currNodeNumber){
		Node* tmp_nd;
		for (int i = 0; i<(n-currNodeNumber); ++i){
			double* pos = new double[3];
			pos[0]=0.0;
			pos[1]=0.0;
			pos[2]=0.0;
			//the positions will be read and updated in function updateNodePositionsFromSave
			tmp_nd = new Node(i, 3, pos);
			Nodes.push_back(tmp_nd);
			delete[] pos;
		}
	}
	else{
		for (int i = 0; i<(currNodeNumber-n); ++i){
			Node* tmp_nd;
			tmp_nd = Nodes.back();
			Nodes.pop_back();
			delete tmp_nd;
		}
	}
	//I have already read the current number of nodes at this step,
	//the "cursor" in the file progressed, I am returning the number,
	//for the next function to use;
	return n;
}

void Simulation::updateNodePositionsFromSave(){
	int n = Nodes.size();
	for (int i=0; i<n; ++i){
		saveFileToDisplay >> Nodes[i]->Position[0];
		saveFileToDisplay >> Nodes[i]->Position[1];
		saveFileToDisplay >> Nodes[i]->Position[2];
	}
}

void Simulation::initiateMesh(int MeshType){
	if (MeshType == 1 ){
		initiateSinglePrismNodes();
		initiateSinglePrismElement();
	}
	else if (MeshType == 2){
		cerr<<"Error: Too few arguments for mesh by dimensions"<<endl;
	}
	else if ( MeshType == 3 || MeshType ==4 ){
		cerr<<"Error: Wrong set of arguments  for mesh triangulation"<<endl;
	}
	else {
		cerr<<"Error: Mesh Type not recognised"<<endl;
	}
}

void Simulation::initiateMesh(int MeshType, int Row, int Column, float SideLength, float zHeight){
	if ( MeshType == 1 ){
		cerr<<"Error: Too many arguments for a single element system"<<endl;
	}
	if ( MeshType == 2){
		initiateNodesByRowAndColumn(Row,Column,SideLength,zHeight);
		initiateElementsByRowAndColumn(Row,Column);
	}
	else if ( MeshType == 3 ){
		cerr<<"Error: Wrong set of arguments  for mesh triangulation"<<endl;
	}
	else if ( MeshType ==4 ){
			cerr<<"Error: Too many arguments for reading the mesh from file"<<endl;
	}
	else {
		cerr<<"Error: Mesh Type not recognised"<<endl;
	}
}

void Simulation::initiateMesh(int MeshType, string inputtype, float SideLength, float zHeight ){
	if ( MeshType == 1 ){
		cerr<<"Error: Too many arguments for a single element system"<<endl;
	}
	if ( MeshType == 2){
		cerr<<"Error: Too few arguments for mesh by dimensions"<<endl;
	}
	else if ( MeshType == 3 ){
		//this will be inputting circumference of the tissue, and the sidelength and z-height
		//generate mesh by triangulation
		float a = zHeight;float b = SideLength;
	}
	else if ( MeshType ==4 ){
		cerr<<"Error: Too many arguments for reading the mesh from file"<<endl;
		//this will be reading full mesh data
		//read mesh data from file
	}
	else {
		cerr<<"Error: Mesh Type not recognised"<<endl;
	}
}

void Simulation::initiateMesh(int MeshType, string inputtype ){
	if ( MeshType == 1 ){
		cerr<<"Error: Too many arguments for a single element system"<<endl;
	}
	if ( MeshType == 2){
		cerr<<"Error: Too few arguments for mesh by dimensions"<<endl;
	}
	else if ( MeshType == 3 ){
		cerr<<"Error: Wrong set of arguments  for mesh triangulation"<<endl;
	}
	else if ( MeshType ==4 ){
		cerr<<"Error: Too many arguments for reading the mesh from file"<<endl;
		//this will be reading full mesh data
		//read mesh data from file
	}
	else {
		cerr<<"Error: Mesh Type not recognised"<<endl;
	}
}

void Simulation::CalculateStiffnessMatrices(){
	for (int i=0; i<Elements.size();++i){
		Elements[i]->calculateReferenceStiffnessMatrix();
	}
}

void Simulation::fixAllD(int i){
	for (int j =0 ; j<Nodes[i]->nDim; ++j){
		Nodes[i]->FixedPos[j]=true;
	}
}

void Simulation::fixZ(int i){
	if(Nodes[i]->nDim>2){
		Nodes[i]->FixedPos[2]=true;
	}
	else{
		cerr<<"ERROR: Node : "<<i<<" does not have z-dimension"<<endl;
	}
}

void Simulation::zeroForcesOnNode(int i){
	double ForceBalance[3];
	ForceBalance[0] = SystemForces[i][0];
	ForceBalance[1] = SystemForces[i][1];
	ForceBalance[2] = SystemForces[i][2];
	int n = Nodes.size();
	for (int i=0;i<n;++i){
		SystemForces[i][0]-=ForceBalance[0];
		SystemForces[i][1]-=ForceBalance[1];
		SystemForces[i][2]-=ForceBalance[2];
	}
}

void Simulation::initiateSystemForces(){
	const int n = Nodes.size();
	SystemForces = new double*[n];
	for (int i=0;i<n;++i){
		SystemForces[i] = new double[3];
		SystemForces[i][0]=0.0;
		SystemForces[i][1]=0.0;
		SystemForces[i][2]=0.0;
		//cout<<"systemforces[i][j]: "<<SystemForces[i][0]<<" "<<SystemForces[i][0]<<" "<<SystemForces[i][0]<<endl;
	}
}

void Simulation::initiateSinglePrismNodes(){
	double *pos = new double[3];
	Node* tmp_nd;
	pos[0]=0;pos[1]=1;pos[2]=0;
	tmp_nd = new Node(0, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=1;pos[1]=0;pos[2]=0;
	tmp_nd = new Node(1, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=0;pos[1]=0;pos[2]=0;
	tmp_nd = new Node(2, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=0;pos[1]=1;pos[2]=1;
	tmp_nd = new Node(3, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=1;pos[1]=0;pos[2]=1;
	tmp_nd = new Node(4, 3, pos);
	Nodes.push_back(tmp_nd);
	pos[0]=0;pos[1]=0;pos[2]=1;
	tmp_nd = new Node(5, 3, pos);
	Nodes.push_back(tmp_nd);
	delete[] pos;
}

void Simulation::initiateSinglePrismElement(){
	int* NodeIds;
	NodeIds = new int[6];
	for (int i = 0; i < 6 ; i++){
		NodeIds[i]=i;
	}
	Prism* PrismPnt01;
	PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
	Elements.push_back(PrismPnt01);
	currElementId++;
	fixZ(0);
	fixZ(1);
	fixZ(2);
}

void Simulation::initiateNodesByRowAndColumn(int Row, int Column, float SideLength, float zHeight){
	//The height of the equilateral triangle with side length: SideLength
	double sqrt3 = 1.7321;
	float h = sqrt3/2*SideLength;
	vector <double> xPos, yPos;
	vector <int> NodesToFix;
	for (int ColCount = 0; ColCount < Column+1; ++ColCount){
		double CurrY = ColCount*h;
		int CurrRowNum = Row + 1 - ColCount;
		double RowOffset = 0.5*SideLength*ColCount;
		for ( int RowCount = 1; RowCount<CurrRowNum+1; ++RowCount){
			double CurrX = RowOffset + RowCount * SideLength;
			xPos.push_back(CurrX);
			yPos.push_back(CurrY);
			if (RowCount ==1 || RowCount == CurrRowNum || ColCount == Column){
				NodesToFix.push_back(xPos.size()-1);
			}
		}
		if (ColCount>0){
			CurrY = (-1.0)*CurrY;
			for ( int RowCount = 1; RowCount<CurrRowNum+1; ++RowCount){
				double CurrX = RowOffset + RowCount * SideLength;
				xPos.push_back(CurrX);
				yPos.push_back(CurrY);
				if (RowCount ==1 || RowCount == CurrRowNum || ColCount == Column){
					NodesToFix.push_back(xPos.size()-1);
				}
			}
		}
	}
	int n =  xPos.size();
	Node* tmp_nd;
	double* pos = new double[3];
	//Adding the lower level of nodes:
	for (int i =0; i< n; ++i){
		pos[0] = xPos[i];
		pos[1] = yPos[i];
		pos[2] = 0.0;
		tmp_nd = new Node(i, 3, pos);
		Nodes.push_back(tmp_nd);
	}
	//Adding the upper level:
	for (int i =0; i< n; ++i){
		pos[0] = xPos[i];
		pos[1] = yPos[i];
		pos[2] = zHeight;
		tmp_nd = new Node(n+i, 3, pos);
		Nodes.push_back(tmp_nd);
	}
	for (int i=0; i<NodesToFix.size(); ++i){
		//fixZ(NodesToFix[i]);
		//this is the upper layer fixing:
		//fixZ(NodesToFix[i]+n);

		fixAllD(NodesToFix[i]);
		fixAllD(NodesToFix[i]+n);
	}
	delete[] pos;
}

void Simulation::initiateElementsByRowAndColumn(int Row, int Column){
	int xinit1 = 0;
	int xinit2 = xinit1+Row+1;
	int xinit3 = 0;
	int xinit4 = xinit1+2*(Row+1)-1;
	int n = Nodes.size()/2.0;

	for (int ColCount = 0; ColCount < Column; ++ColCount){
		int CurrRowNum = Row + 1 - ColCount;
		for (int RowCount = 0; RowCount<CurrRowNum-1; ++RowCount ){
			int* NodeIds;
			NodeIds = new int[6];

			NodeIds[0] = xinit1+RowCount;
			NodeIds[1] = xinit1+RowCount+1;
			NodeIds[2] = xinit2+RowCount;
			NodeIds[3] = NodeIds[0] + n;
			NodeIds[4] = NodeIds[1] + n;
			NodeIds[5] = NodeIds[2] + n;
			Prism* PrismPnt01;
			PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
			Elements.push_back(PrismPnt01);
			currElementId++;

			NodeIds[0] = xinit3+RowCount;
			NodeIds[1] = xinit4+RowCount;
			NodeIds[2] = xinit3+RowCount+1;
			NodeIds[3] = NodeIds[0] + n;
			NodeIds[4] = NodeIds[1] + n;
			NodeIds[5] = NodeIds[2] + n;
			PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
			Elements.push_back(PrismPnt01);
			currElementId++;
		}
		for (int RowCount = 0; RowCount<CurrRowNum-2; ++RowCount ){
			int* NodeIds;
			NodeIds = new int[6];

			NodeIds[0] = xinit2+RowCount;
			NodeIds[1] = xinit1+RowCount+1;
			NodeIds[2] = xinit2+RowCount+1;
			NodeIds[3] = NodeIds[0] + n;
			NodeIds[4] = NodeIds[1] + n;
			NodeIds[5] = NodeIds[2] + n;
			Prism* PrismPnt01;
			PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
			Elements.push_back(PrismPnt01);
			currElementId++;

			NodeIds[0] = xinit4+RowCount;
			NodeIds[1] = xinit4+RowCount+1;
			NodeIds[2] = xinit3+RowCount+1;
			NodeIds[3] = NodeIds[0] + n;
			NodeIds[4] = NodeIds[1] + n;
			NodeIds[5] = NodeIds[2] + n;
			PrismPnt01 = new Prism(NodeIds, Nodes, currElementId);
			Elements.push_back(PrismPnt01);
			currElementId++;

		}
		xinit1 = xinit2;
		xinit2 = xinit4 + CurrRowNum-1;
		xinit3 = xinit4;
		xinit4 = xinit2 + CurrRowNum-2;
	}
	cout<<"finalised element initiation"<<endl;
}

void Simulation::calculateSystemCentre(){
	int n = Nodes.size();
	for (int i = 0; i< n; ++i){
		for (int j =0; j<Nodes[i]->nDim; ++j){
			SystemCentre[j] += Nodes[i]->Position[j];
		}
	}
	SystemCentre[0]= SystemCentre[0]/n;
	SystemCentre[1]= SystemCentre[1]/n;
	SystemCentre[2]= SystemCentre[2]/n;
}

void Simulation::assignPhysicalParameters(){
	for (int i=0; i<Elements.size();++i){
		float noise1 = rand() % 2*noiseOnPysProp[0];
		noise1 = 1 + (noise1 - noiseOnPysProp[0]) /100;
		float noise2 = rand() % 2*noiseOnPysProp[1];
		noise2 = 1 + (noise2- noiseOnPysProp[1])/100;
		Elements[i]->setElasticProperties(E*noise1,poisson*noise2);
		float noise3 = rand() % 2*noiseOnPysProp[1];
		noise3 = 1 + (noise3- noiseOnPysProp[2])/100;
		Elements[i]->setViscosity(ApicalVisc*noise3, BasalVisc*noise3, Nodes);
	}
}

void Simulation::runOneStep(){
	cleanreferenceupdates();
	if(nGrowthFunctions>0){
		growSystem();
	}
	const int n = Nodes.size();
	const int dim = 3;
	for (int i=0;i<n;++i){
		for (int j=0;j<dim;++j){
			SystemForces[i][j]=0.0;
		}
	}
	int nElement = Elements.size();
	for (int i=0; i<nElement; ++i){
		//aligning the centres:
		Elements[i]->alignReference();
		if (Elements[i]->updatedReference){
			Elements[i]->calculateReferenceStiffnessMatrix();
		}
		//calculating the forces:
		Elements[i]->calculateForces(1,SystemForces, Nodes);
	}
	//Fixing Node 0 in space:
	//zeroForcesOnNode(0);

	//Update Node positions:
	for (int i=0;i<n;++i){
		for (int j=0; j<Nodes[i]->nDim; ++j){
			Nodes[i]->Velocity[j] = SystemForces[i][j]/Nodes[i]->Viscosity;
			Nodes[i]->Position[j] += Nodes[i]->Velocity[j]*dt;
		}
	}
	for (int i=0;i<Elements.size();++i){
		Elements[i]->updatePositions(Nodes);
	}
	if (saveData && timestep % dataSaveInterval == 0){
		saveStep();
	}
	timestep++;

}

void Simulation::saveStep(){
	outputFile<<"Saving step: "<< timestep<<" this is :"<<timestep*dt<<" sec"<<endl;
	writeSaveFileStepHeader();
	writeNodes();
	writeElements();
	writeSaveFileStepFooter();

}

void Simulation::writeSaveFileStepHeader(){
	dataSaveFile<<"=============== TIME: ";
	dataSaveFile.precision(6);
	dataSaveFile.width(10);
	dataSaveFile<<timestep*dt;
	dataSaveFile<<"==================================================="<<endl;
}

void Simulation::writeSaveFileStepFooter(){
	dataSaveFile<<"=============== END OF TIME: ";
	dataSaveFile.precision(6);
	dataSaveFile.width(10);
	dataSaveFile<<timestep*dt;
	dataSaveFile<<"============================================"<<endl;
}

void Simulation::writeNodes(){
	int n = Nodes.size();
	dataSaveFile<<n<<endl;
	for (int i = 0; i<n; ++i){
		if(Nodes[i]->nDim==2){
			dataSaveFile.precision(3);dataSaveFile.width(10);
			dataSaveFile<<Nodes[i]->Position[0];
			dataSaveFile.precision(3);dataSaveFile.width(10);
			dataSaveFile<<Nodes[i]->Position[1];
			dataSaveFile.precision(3);dataSaveFile.width(10);
			dataSaveFile<<0.0<<endl;

		}
		else{
			int ndim = Nodes[i]->nDim;
			for (int j=0;j<ndim;++j){
				dataSaveFile.precision(3);dataSaveFile.width(10);
				dataSaveFile<<Nodes[i]->Position[j];
			}
			dataSaveFile<<endl;
		}
	}
}

void Simulation::writeElements(){
	int n= Elements.size();
	dataSaveFile<<n<<endl;
	for (int i = 0; i<n; ++i){
		int shapetype = Elements[i]->getShapeType();
		dataSaveFile.width(4);
		dataSaveFile<<shapetype;
		int nodeNumber = Elements[i]->getNodeNumber();
		int*  NodeIds = Elements[i]->getNodeIds();
		for (int j = 0; j<nodeNumber; ++j ){
			dataSaveFile.width(5);dataSaveFile<<NodeIds[j];
		}
		int dim  = Elements[i]->getDim();
		double** refPos = Elements[i]->getReferencePos();
		for (int j = 0; j<nodeNumber; ++j ){
			for (int k = 0; k<dim; ++k ){
				dataSaveFile.precision(3);dataSaveFile.width(10);
				dataSaveFile<<refPos[j][k];
			}
		}
		dataSaveFile<<endl;
	}
}

void Simulation::growSystem(){
	int currIndexForParameters = 0;
	cleanUpGrowthRates();
	for (int i=0; i<nGrowthFunctions; ++i){
		if(GrowthFunctionTypes[i] == 1){
			growSystemCircular(currIndexForParameters);
			currIndexForParameters += 8;
		}
	}
}

void Simulation::cleanreferenceupdates(){
	int nElement = Elements.size();
	for (int i=0; i<nElement; ++i){
		Elements[i]->updatedReference = false;
	}
}

void Simulation::cleanUpGrowthRates(){
	int  n = Elements.size();
	for ( int i = 0; i < n; ++i ){
		Elements[i]->setGrowthRate(0.0,0.0,0.0);
	}
}

void Simulation::growSystemCircular(int currIndex){
	float initTime = GrowthParameters[currIndex];
	float endTime = GrowthParameters[currIndex+1];
	float simTime = dt*timestep;
	if(simTime > initTime && simTime < endTime ){
		//The growth function is active at current time, now I will grow the elements.
		//First get the remaining data from the growth function parameters
		float centre[2] = {GrowthParameters[currIndex+2], GrowthParameters[currIndex+3]};
		float radius = {GrowthParameters[currIndex+4]};
		float MaxValue[3] = {GrowthParameters[currIndex+5],GrowthParameters[currIndex+6],GrowthParameters[currIndex+7]};
		float radius2 = radius*radius;
		int  n = Elements.size();
		for ( int i = 0; i < n; ++i ){
			double* Elementcentre = new double[3];
			Elementcentre = Elements[i]->getCentre();
			//the distance is calculated in the x-y projection
			double d[2] = {centre[0] - Elementcentre[0], centre[1] - Elementcentre[1]};
			double dmag2 = d[0]*d[0] + d[1]*d[1];
			if (dmag2 < radius2){
				//the element is within the growth zone.
				float distance = pow(dmag2,0.5);
				//calculating the growth rate: as a fraction increase within this time point
				double sf = (1.0 - distance /radius );
				double growthscale[3] = {1+MaxValue[0] * sf, 1+MaxValue[1] * sf, 1+MaxValue[2] * sf};
				//growing the shape, it will be scaled up to the value 1 + growth rate
				Elements[i]->growShape(growthscale[0], growthscale[1], growthscale[2]);
				//This value is stored as fraction per hour, conversion is done by a time scale variable:
				float timescale = 60*60/dt;
				Elements[i]->updateGrowthRate(MaxValue[0]*timescale,MaxValue[1]*timescale,MaxValue[2]*timescale);
			}
			delete[] Elementcentre;
		}
	}
}
