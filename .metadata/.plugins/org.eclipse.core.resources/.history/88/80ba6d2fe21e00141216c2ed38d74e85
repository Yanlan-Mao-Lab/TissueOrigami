#include "ShapeBase.h"
#include "Node.h"
#include <sstream>

void 	ShapeBase::ParentErrorMessage(){
	cerr<<"You are calling the function from a parent here, check declaration is via pointers"<<endl;
}

void	ShapeBase::setShapeType(string TypeName){
	if (TypeName == "Prism"){
		this->ShapeType = 1;
	}
	else{
		this->ShapeType= -100;
	};
}

void	ShapeBase::setIdentificationColour(){
	IdentifierColour[2] = Id % 255;
	int a = (Id - IdentifierColour[2]) / 255;
	IdentifierColour[1] = ( a ) % 255;
	if (a>255){
		IdentifierColour[0] = (a - IdentifierColour[1]) / 255;
	}
	else{
		IdentifierColour[0] = 0;
	}
	//cout<<"IdentifierColour: "<<IdentifierColour[0]<<" "<<IdentifierColour[1]<<" "<<IdentifierColour[2]<<endl;
}

int		ShapeBase::getShapeType(){
	return ShapeType;
}

int 	ShapeBase::getId(){
	return Id;
}

int 	ShapeBase::getNodeNumber(){
	return nNodes;
}

int* 	ShapeBase::getNodeIds(){
	return NodeIds;
}

int 	ShapeBase::getDim(){
	return nDim;
}

string 	ShapeBase::getName(){
	string name;
	if (ShapeType == 1){
		name = "Prism";
	}
	else{
		name = "Unknown";
	}
	stringstream inter;
	inter.fill('0');
	inter.width(4);
	inter<<Id;
	name = name + inter.str();
	return name;
}

double** ShapeBase::getReferencePos(){
	return ReferenceShape->Positions;
}

double*	 ShapeBase::getReferenceNormal(){
	return ReferenceShape->CurrentNormal;
}

double 	ShapeBase::getYoungModulus(){
	return E;
}

double 	ShapeBase::getPoissonRatio(){
	return v;
}

double* ShapeBase::getGrowthRate(){
	return GrowthRate;
}

double* ShapeBase::getCentre(){
	double* d = new double[3];
	d[0]= 0.0; d[1]= 0.0; d[2]=0.0;
	for (int i = 0; i<nNodes; ++i ){
		for (int j = 0; j< nDim; ++j){
			d[j] += Positions[i][j];
		}
	}
	d[0] /= nNodes; d[1] /= nNodes; d[2] /= nNodes;
	return d;
}

void 	ShapeBase::readNodeIds(int* inpNodeIds){
	for (int i=0; i<nNodes; ++i){
		this->NodeIds[i] = inpNodeIds[i];
	}
}

void 	ShapeBase::displayName(){
	cout<<"Type: "<<this->ShapeType<<" Id: "<<this->Id<<endl;
}

void 	ShapeBase::setPositionMatrix(vector<Node*>& Nodes){
	const int n = nNodes;
	const int dim = nDim;
	Positions = new double*[n];
	for (int i = 0; i<nNodes; ++i){
		Positions[i] = new double[dim];
		for (int j = 0; j<dim; ++j){
			Positions[i][j] = Nodes[NodeIds[i]]->Position[j];
		}
	}
}

void 	ShapeBase::setReferencePositionMatrix(){
	const int n = nNodes;
	const int dim = nDim;
	ReferenceShape -> Positions = new double*[n];
	for (int i = 0; i<nNodes; ++i){
		ReferenceShape -> Positions[i] = new double[dim];
		for (int j = 0; j<dim; ++j){
			ReferenceShape -> Positions[i][j] = Positions[i][j];
		}
	}
}

void 	ShapeBase::updateShapeFromSave(ifstream& file){
	updateNodeIdsFromSave(file);
	updateReferencePositionMatrixFromSave(file);
}

void 	ShapeBase::updateNodeIdsFromSave(ifstream& file){
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			int savedId;
			file >> savedId;
			NodeId[i][j] = savedPos;
		}
	}
}

void 	ShapeBase::updateReferencePositionMatrixFromSave(ifstream& file){
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			double savedPos;
			file >> savedPos;
			ReferenceShape -> Positions[i][j] = savedPos;
		}
	}
}

void 	ShapeBase::displayPositions(){
	for (int i=0; i<nNodes;++i){
		for (int j =0; j<nDim; ++j){
			cout<<Positions[i][j]<<"  ";
		}
		cout<<endl;
	}
}

int*	ShapeBase::getIdentifierColour(){
	return IdentifierColour;
}

void 	ShapeBase::getStrainColour(int type, float* StrainColour){
	//We will scale the strain from -5 to +5 in 0 to 1 colour channel blue:
	//We will scale the strain from -5 to +5 in 1 to 0 colour channel red:

	float minStrain = -1.0;
	float maxStrain = 1.0;
	float SumStrain = 0.0;
	float rb = StrainColour[0];
	float gb = StrainColour[1];
	float bb = StrainColour[2];
	if (type == 0){
		for (int i=0; i<3; ++i){
			SumStrain += Strain(i);
		}
	}
	else if (type == 1){
		SumStrain = Strain(0);
	}
	else if (type == 2){
		SumStrain = Strain(1);
	}
	else if (type == 3){
		SumStrain = Strain(2);
	}
	else{
		return;
	}
	if (SumStrain<0){
		StrainColour[0] = 1.0 - (SumStrain - minStrain)/(0.0 -minStrain) * (1-rb);
		minStrain = minStrain/2.0;
		StrainColour[1] = (SumStrain - minStrain)/(0.0 - minStrain) * (gb);
		StrainColour[2] = (SumStrain - minStrain)/(0.0 - minStrain) * (bb);
	}
	else{
		StrainColour[0] = rb - SumStrain/maxStrain*rb;
		StrainColour[1] = gb - (SumStrain - 0.0)/(maxStrain - 0.0) * (gb);
		StrainColour[2] = bb + (SumStrain - 0.0)/(maxStrain - 0.0) * (1-bb);
	}
	//cout<<"Strain: "<<Strain(0)<<" "<<Strain(1)<<" "<<Strain(2)<<" colour: "<< StrainColour[0]<<" "<<StrainColour[1]<<" "<<StrainColour[2]<<endl;
}

void 	ShapeBase::getStrain(int type, float &StrainMag){
	StrainMag = 0.0;
	if (type == 0){
		for (int i=0; i<3; ++i){
			StrainMag += Strain(i);
		}
	}
	else if (type == 1){
		StrainMag = Strain(0);
	}
	else if (type == 2){
		StrainMag = Strain(1);
	}
	else if (type == 3){
	}
	else{
		return;
	}
}

void 	ShapeBase::getNodeBasedPysProp(int type, int NodeNo, vector<Node*>& Nodes, float& PysPropMag){
	PysPropMag = 0.0;
	if (type == 0){
		PysPropMag = Nodes[NodeIds[NodeNo]] -> Viscosity;
	}
}

void 	ShapeBase::getPysProp(int type, float &PysPropMag){
	PysPropMag = 0.0;
	if (type ==1){
		PysPropMag = getYoungModulus();
	}
	else if (type == 2 ){
		PysPropMag = getPoissonRatio();
	}
	else if (type ==3){
		double* growth;
		growth = new double[3];
		growth = getGrowthRate();
		for (int i =0 ; i< nDim ; ++i){
			PysPropMag += growth[i];
		}
	}
}

void 	ShapeBase::displayIdentifierColour(){
	cout <<" IdentifierColour:  "<<IdentifierColour[0]<<" "<<IdentifierColour[1]<<" "<<IdentifierColour[2]<<endl;
}

void 	ShapeBase::alignReference(){
	updateAlignmentTurn();
	calculateNormals();
	double *v,*u;
	v = new double[3];
	u = new double[3];
	for (int i=0;i<nDim; ++i){
		v[i] = CurrentNormal[i];
		u[i] = ReferenceShape->CurrentNormal[i];
	}
	double c, s;
	calculateRotationAngleSinCos(u,v,c,s);
	double *rotAx;
	rotAx = new double[3];
	double *rotMat;
	rotMat = new double[9]; //matrix is written in one row
	if (c<0.9998){ //only rotate if the vectors are more than 1 degree apart
		updatedReference = true;
		//cout<<"Aligning the plane, angle big enough - cos: "<<c<<" sin: "<<s<<endl;
		calculateRotationAxis(u,v,rotAx);
		constructRotationMatrix(c,s,rotAx,rotMat);
		double centre[3];
		for (int i=0; i<nNodes; ++i){
			u[0] = ReferenceShape->Positions[i][0];
			u[1] = ReferenceShape->Positions[i][1];
			u[2] = ReferenceShape->Positions[i][2];
			rotateVectorByRotationMatrix(u,rotMat);
			ReferenceShape->Positions[i][0] = u[0];
			ReferenceShape->Positions[i][1] = u[1];
			ReferenceShape->Positions[i][2] = u[2];
		}
		//Aligned the planes, now align the sides:
	}
	//else{ cout<<"skipping plane alignment, degree is too small: cosine: "<<c<<" sine: "<<s<<endl;}
	double* RefSide;
	RefSide = new double[3];
	double* ShapeSide;
	ShapeSide = new double[3];

	getCurrentAlignmentSides(RefSide, ShapeSide);
	calculateRotationAngleSinCos(RefSide,ShapeSide,c,s);
	if (c<0.9998){  //only rotate if the vectors are more than 1 degree apart
		updatedReference = true;
		//cout<<"Aligning the side, angle big enough - cos: "<<c<<" sin: "<<s<<endl;
		calculateRotationAxis(RefSide,ShapeSide,rotAx);
		constructRotationMatrix(c,s,rotAx,rotMat);
		for (int i=0; i<nNodes; ++i){
			u[0] = ReferenceShape->Positions[i][0];
			u[1] = ReferenceShape->Positions[i][1];
			u[2] = ReferenceShape->Positions[i][2];
			rotateVectorByRotationMatrix(u,rotMat);
			ReferenceShape->Positions[i][0] = u[0];
			ReferenceShape->Positions[i][1] = u[1];
			ReferenceShape->Positions[i][2] = u[2];
		}
		//Now they are aligned, but I do not know if they face the same direction, so I need to check that:
		/*
		bool facecorrection = areSidesFacingSameDirection(RefSide, ShapeSide);
		if (!facecorrection){
			//face is in the wrong direction, I need to rotate the element a further 180 degrees
			constructRotationMatrix(-1.0,0.0,rotAx,rotMat);
			for (int i=0; i<nNodes; ++i){
				u[0] = ReferenceShape->Positions[i][0];
				u[1] = ReferenceShape->Positions[i][1];
				u[2] = ReferenceShape->Positions[i][2];
				rotateVectorByRotationMatrix(u,rotMat);
				ReferenceShape->Positions[i][0] = u[0];
				ReferenceShape->Positions[i][1] = u[1];
				ReferenceShape->Positions[i][2] = u[2];
			}
			cout<<"Reference positions after face correction: "<<endl;
			for (int i = 0; i<nNodes; ++i){
				for (int j = 0; j<nDim; ++j){
					cout<<ReferenceShape->Positions[i][j]<<" ";
				}
				cout<<endl;
			}
			cout<<endl;

		}
		*/
	}
	//else{ cout<<"skipping side alignment, degree is too small: cosine: "<<c<<" sine: "<<s<<endl;}
	//aligning the position to the curr shape centre:
	double translocation[3] = {0.0,0.0,0.0};
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			translocation[j] +=  Positions[i][j] - ReferenceShape ->Positions[i][j];
		}
	}
	for (int j = 0; j<nDim; ++j){
		translocation[j] /= nNodes;
	}
	//translocation[0] -= 5.0;
	for (int i = 0; i<nNodes; ++i){
			for (int j = 0; j<nDim; ++j){
				ReferenceShape->Positions[i][j] +=translocation[j];
			}
	}
	delete[] u;
	delete[] v;
	delete[] rotAx;
	delete[] rotMat;
	delete[] RefSide;
	delete[] ShapeSide;
}

bool	ShapeBase::areSidesFacingSameDirection(double* RefSide, double* ShapeSide){
	double* RefFace;
	RefFace = new double[3];
	double* ShapeFace;
	ShapeFace = new double[3];
	getCurrentAlignmentFaces(RefSide, ShapeSide, RefFace, ShapeFace);
	double dotp = dotProduct3D(RefFace,ShapeFace);
	if ( dotp < 0){
		return false;
	}
	else{
		return true;
	}
	delete[] RefFace;
	delete[] ShapeFace;
}

void	ShapeBase::calculateRotationAngleSinCos(double* u, double* v, double& c, double& s){
	//aligning u onto v:
	c = dotProduct3D(u,v);
	if (c > 1.0){
		c = 1.0;
		s = 0.0;
	}
	else if( c<-1.0){
		c = -1.0;
		s = 0.0;
	}
	else{
		double tet = acos(c);
		s = sin(tet);
	}
}

void	ShapeBase::calculateRotationAxis(double* u, double* v,double* rotAx){
	//aligning u onto v:
	crossProduct3D(u,v,rotAx);
	normaliseVector3D(rotAx);
}

void	ShapeBase::constructRotationMatrix(double c, double s, double* rotAx, double* rotMat){
	//cout<<" Rotation axis: "<<rotAx[0]<<" "<<rotAx[1]<<" "<<rotAx[2]<<endl;

	rotMat[0] = c + rotAx[0]*rotAx[0]*(1 - c);
	rotMat[1] = rotAx[0]*rotAx[1]*(1 - c) - rotAx[2]*s;
	rotMat[2] = rotAx[0]*rotAx[2]*(1 - c) + rotAx[1]*s;

	rotMat[3] = rotAx[1]*rotAx[0]*(1 - c) + rotAx[2]*s;
	rotMat[4] = c + rotAx[1]*rotAx[1]*(1 - c);
	rotMat[5] = rotAx[1]*rotAx[2]*(1 - c) - rotAx[0]*s;

	rotMat[6] = rotAx[2]*rotAx[0]*(1 - c) - rotAx[1]*s;
	rotMat[7] = rotAx[2]*rotAx[1]*(1 - c) + rotAx[0]*s;
	rotMat[8] = c + rotAx[2]*rotAx[2]*(1 - c);

	/*cout<<"Rotation Matrix: "<<endl;
	cout<<rotMat[0]<<" "<<rotMat[1]<<" "<<rotMat[2]<<endl;
	cout<<rotMat[3]<<" "<<rotMat[4]<<" "<<rotMat[5]<<endl;
	cout<<rotMat[6]<<" "<<rotMat[7]<<" "<<rotMat[8]<<endl;*/
}

void	ShapeBase::rotateVectorByRotationMatrix(double* u,double* rotMat){
	double x = rotMat[0]*u[0]+rotMat[1]*u[1]+rotMat[2]*u[2];
	double y = rotMat[3]*u[0]+rotMat[4]*u[1]+rotMat[5]*u[2];
	double z = rotMat[6]*u[0]+rotMat[7]*u[1]+rotMat[8]*u[2];
	//cout<<"before rotation: "<<u[0]<<" "<<u[1]<<" "<<u[2]<<endl;
	u[0] = x;
	u[1] = y;
	u[2] = z;
	//cout<<"after rotation: "<<u[0]<<" "<<u[1]<<" "<<u[2]<<endl;
}

void	ShapeBase::NormaliseQuaternian(double* Qrot){
	//Normalising the input:
	double mag2 = Qrot[0] * Qrot[0] + Qrot[1] * Qrot[1] + Qrot[2] * Qrot[2] + Qrot[3] * Qrot[3];
	if (fabs(mag2) > 0.00000001 && fabs(mag2 - 1.0f) > 0.00000001) {
		double mag = pow(mag2,0.5);
		Qrot[0] /= mag;
		Qrot[1] /= mag;
		Qrot[2] /= mag;
		Qrot[3] /= mag;
	}
 }

void	ShapeBase::RotateVectorByQuaternian(double* u, double* Qrot){
	//roation of vector u wit quaternian q is calculated as:
	// u' = q*u*q^-1;
	//for a normalised quaternian, inverse is equal to the conjugate (q*)
	//conjugate of a quaternian is: q = a_ bi+cj+dk => q* = a -bi-cj-dk
	/*double q1 = Qrot[0], q2 = Qrot[1], q3 = Qrot[2], q4 = Qrot[3];
	double u1 = u[0], u2 = u[1], u3 = u[2];
	double constant = q2*u1 + q3*u2 + q4*u3;
	double A = q1*u1 + q2*u2 - q3*u1;
	double B = q1*u2 - q2*u2 +q4*u1;
	double C = q1*u3 + q2*u2 + q3*u1;

	double ConstantPartOfRot = (-constant*q1) + A*q2 + B*q3 +C*q4;
	if (ConstantPartOfRot > 10E-10 || ConstantPartOfRot < -10E-10){
		cerr<<"Rotation has resisual!, normalise quaternian"<<endl;
	}
	u[0] = constant*q2 + A*q1 - B*q4 + C*q3;
	u[1] = constant*q3 + A*q4 + B*q1 + C*q2;
	u[2] = constant*q4 - A*q3 + B*q2 + C*q1;
*/
	double RotMat[3][3];
	RotMat[0][0] = 1 - 2*Qrot[2]*Qrot[2] - 2*Qrot[3]*Qrot[3];
	RotMat[0][1] = 2*(Qrot[1]*Qrot[2] + Qrot[0]*Qrot[3]);
	RotMat[0][2] = 2*(Qrot[1]*Qrot[3] - Qrot[0]*Qrot[2]);

	RotMat[1][0] = 2*(Qrot[1]*Qrot[2] - Qrot[0]*Qrot[3]);
	RotMat[1][1] = 1 - 2*Qrot[1]*Qrot[1] - 2* Qrot[3]*Qrot[3];
	RotMat[1][2] = 2*(Qrot[2]*Qrot[3] + Qrot[0]*Qrot[1]);

	RotMat[2][0] = 2*(Qrot[1]*Qrot[3] + Qrot[0]*Qrot[2]);
	RotMat[2][1] = 2*(Qrot[2]*Qrot[3] - Qrot[0]*Qrot[1]);
	RotMat[2][2] = 1 - 2*Qrot[1]*Qrot[1] - 2*Qrot[2]*Qrot[2];

	double x = RotMat[0][0]*u[0] + RotMat[0][1]*u[1] +RotMat[0][2]*u[2];
	double y = RotMat[1][0]*u[0] + RotMat[1][1]*u[1] +RotMat[1][2]*u[2];
	double z = RotMat[2][0]*u[0] + RotMat[2][1]*u[1] +RotMat[2][2]*u[2];

	u[0] = x; u[1] = y; u[2] = z;

}

void	ShapeBase::calculateRotationQuaternian(double* u, double* v,double* Qrot){
	//align v onto u:
	double *cross;
	cross = new double[3];
	crossProduct3D(v,u, cross);
	normaliseVector3D(cross);
	double dot;
	dot = dotProduct3D(v,u);
	float angle = acosf(min(1.0,dot));
	Qrot[0]= cosf(angle); Qrot[1] = sinf(angle)* cross[0]; Qrot[2] = sinf(angle)*cross[1]; Qrot[3] = sinf(angle)*cross[2];

	delete[] cross;
}

void	ShapeBase::calculateForces(int RKid, double **SystemForces, vector <Node*>& Nodes){
	const int nMult = nNodes*nDim;

	using namespace boost::numeric::ublas;
	boost::numeric::ublas::vector<double> displacement(nMult);
	int counter = 0;
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			displacement(counter) = Positions[i][j]-ReferenceShape->Positions[i][j];
			counter++;
		}
	}

	Forces = zero_vector<double>(nMult);
	boost::numeric::ublas::axpy_prod(k,displacement,Forces);
	boost::numeric::ublas::axpy_prod(B,displacement,Strain);
	counter = 0;
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			if (!Nodes[NodeIds[i]]->FixedPos[j]){
				SystemForces[NodeIds[i]][j] = SystemForces[NodeIds[i]][j] - Forces(counter);
			}
			counter++;
		}
	}
	/*
	cout<<"Element: "<<Id<<endl;
	cout<<"positions: "<<endl;
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			cout<<Positions[i][j]<<" ";
		}
		cout<<endl;
	}
	cout<<"Reference positions: "<<endl;
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			cout<<ReferenceShape->Positions[i][j]<<" ";
		}
		cout<<endl;
	}
	displayMatrix(displacement,"displacement");
	displayMatrix(Forces,"Forces");
	cout<<"SystemForces:"<<endl;
	int nSysNodes = Nodes.size();
	for (int i=0;i<nSysNodes;++i){
		for (int j=0;j<3;++j){
			cout<<SystemForces[i][j]<<" ";
		}
		cout<<endl;
	}
	cout<<endl;*/
}

void	ShapeBase::updatePositions(vector<Node*>& Nodes){
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
				Positions[i][j] = Nodes[NodeIds[i]]->Position[j];
		}
	}
}

void 	ShapeBase::setGrowthRate(double x, double y, double z){
	GrowthRate[0] = x;
	GrowthRate[1] = y;
	GrowthRate[2] = z;
}

void 	ShapeBase::growShape(double scalex, double scaley, double scalez){
	updatedReference = true;
	//cout<<"growing shape: "<<Id<<endl;
	//Growing the shape in x, y and z dimentions with the input scale factors.
	//This algorithm will work only if the reference elements are aligned with the current
	//elements! The x -y directions will fails otherwise!
	float scale[3] = {scalex, scaley,scalez};
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			ReferenceShape -> Positions[i][j] = ReferenceShape -> Positions[i][j] * scale[j];
		}
	}

}

void 	ShapeBase::updateGrowthRate(double scalex, double scaley, double scalez){
	//This value is stored as per hour:
	GrowthRate[0] += scalex;
	GrowthRate[1] += scaley;
	GrowthRate[2] += scalez;
}

bool 	ShapeBase::InvertMatrix(boost::numeric::ublas::matrix<double>& input, boost::numeric::ublas::matrix<double>& inverse, double& det){
	//Matrix inversion routine.
	//Uses lu_factorize and lu_substitute in uBLAS to invert a matrix
	using namespace boost::numeric::ublas;
	typedef permutation_matrix<std::size_t> pmatrix;

	// create a working copy of the input
	matrix<double> A(input);

	// create a permutation matrix for the LU-factorization
	pmatrix pm(A.size1());

	// perform LU-factorization
	int res = lu_factorize(A, pm);
	if (res != 0)
		return false;

	det = 1.0;
	for(int i = 0; i < A.size1(); i++) {
		det *= A(i,i); // multiply by elements on diagonal
	    det = det * determinant_sign( pm );
	}
	// create identity matrix of "inverse"
	inverse.assign(identity_matrix<double> (A.size1()));

	// backsubstitute to get the inverse
	lu_substitute(A, pm, inverse);

	return true;
}

int 	ShapeBase::determinant_sign(boost::numeric::ublas::permutation_matrix<std::size_t>& pm)
{
    int pm_sign=1;
    std::size_t size = pm.size();
    for (std::size_t i = 0; i < size; ++i)
        if (i != pm(i))
            pm_sign *= -1.0; // swap_rows would swap a pair of rows here, so we change sign
    return pm_sign;
}

void	ShapeBase::crossProduct3D(double* u, double* v, double* cross){
	cross[0] = u[1]*v[2] - u[2]*v[1];
	cross[1] = u[2]*v[0] - u[0]*v[2];
	cross[2] = u[0]*v[1] - u[1]*v[0];
}

void	ShapeBase::normaliseVector3D(double* v){
	double mag2 = v[0]*v[0]+v[1]*v[1]+v[2]*v[2];
	if (fabs(mag2) > 1E-14 && fabs(mag2 - 1.0f) > 1E-14) {
		double mag = pow(mag2,0.5);
		v[0] /= mag;
		v[1] /= mag;
		v[2] /= mag;
	}
}

double 	ShapeBase::dotProduct3D(double* u, double* v){
	double dot = 0;
	dot = u[0]*v[0]+u[1]*v[1]+u[2]*v[2];
	return dot;
}

void 	ShapeBase::displayMatrix(boost::numeric::ublas::matrix<double>& mat, string matname){
	int m = mat.size1();
	int n = mat.size2();
	cout<<matname<<": "<<endl;

	for (int i =0; i<m; i++){
		for (int j =0; j<n; j++){
			cout.precision(4);
			cout.width(6);
			cout<<mat(i,j)<<" ";
		}
		cout<<endl;
	}
	cout<<endl;
}

void 	ShapeBase::displayMatrix(boost::numeric::ublas::matrix<int>& mat, string matname){
	int m = mat.size1();
	int n = mat.size2();
	cout<<matname<<": "<<endl;

	for (int i =0; i<m; i++){
		for (int j =0; j<n; j++){
			cout.precision(4);
			cout.width(6);
			cout<<mat(i,j)<<" ";
		}
		cout<<endl;
	}
	cout<<endl;
}

void	ShapeBase::displayMatrix(boost::numeric::ublas::vector<double>& vec, string matname){
	int m = vec.size();
	cout<<matname<<": "<<endl;
	for (int i =0; i<m; i++){
		cout.precision(4);
		cout.width(6);
		cout<<vec(i)<<" ";
	}
	cout<<endl;
}
