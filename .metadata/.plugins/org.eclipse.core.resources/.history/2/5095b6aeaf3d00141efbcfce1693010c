#include "ShapeBase.h"
#include "Node.h"
#include <sstream>

void 	ShapeBase::ParentErrorMessage(){
	cerr<<"You are calling the function from a parent here, check declaration is via pointers"<<endl;
}

void	ShapeBase::setShapeType(string TypeName){
	if (TypeName == "Prism"){
		this->ShapeType = 1;
	}
	else{
		this->ShapeType= -100;
	};
}

void	ShapeBase::setIdentificationColour(){
	IdentifierColour[2] = Id % 255;
	int a = (Id - IdentifierColour[2]) / 255;
	IdentifierColour[1] = ( a ) % 255;
	if (a>255){
		IdentifierColour[0] = (a - IdentifierColour[1]) / 255;
	}
	else{
		IdentifierColour[0] = 0;
	}
	//cout<<"IdentifierColour: "<<IdentifierColour[0]<<" "<<IdentifierColour[1]<<" "<<IdentifierColour[2]<<endl;
}

int		ShapeBase::getShapeType(){
	return ShapeType;
}

int 	ShapeBase::getId(){
	return Id;
}

int 	ShapeBase::getNodeNumber(){
	return nNodes;
}

int* 	ShapeBase::getNodeIds(){
	return NodeIds;
}

int 	ShapeBase::getDim(){
	return nDim;
}

string 	ShapeBase::getName(){
	string name;
	if (ShapeType == 1){
		name = "Prism";
	}
	else{
		name = "Unknown";
	}
	stringstream inter;
	inter.fill('0');
	inter.width(4);
	inter<<Id;
	name = name + inter.str();
	return name;
}

double** ShapeBase::getReferencePos(){
	return ReferenceShape->Positions;
}

double*	 ShapeBase::getReferenceNormal(){
	return ReferenceShape->CurrentNormal;
}

double 	ShapeBase::getYoungModulus(){
	return E;
}

double 	ShapeBase::getPoissonRatio(){
	return v;
}

double* ShapeBase::getGrowthRate(){
	return GrowthRate;
}

double* ShapeBase::getShapeChangeRate(){
	return ShapeChangeRate;
}

double* ShapeBase::getCentre(){
	double* d = new double[3];
	d[0]= 0.0; d[1]= 0.0; d[2]=0.0;
	for (int i = 0; i<nNodes; ++i ){
		for (int j = 0; j< nDim; ++j){
			d[j] += Positions[i][j];
		}
	}
	d[0] /= nNodes; d[1] /= nNodes; d[2] /= nNodes;
	return d;
}

void 	ShapeBase::readNodeIds(int* inpNodeIds){
	for (int i=0; i<nNodes; ++i){
		this->NodeIds[i] = inpNodeIds[i];
	}
}

void 	ShapeBase::displayName(){
	cout<<"Type: "<<this->ShapeType<<" Id: "<<this->Id<<endl;
}

void 	ShapeBase::setPositionMatrix(vector<Node*>& Nodes){
	const int n = nNodes;
	const int dim = nDim;
	Positions = new double*[n];
	for (int i = 0; i<nNodes; ++i){
		Positions[i] = new double[dim];
		for (int j = 0; j<dim; ++j){
			Positions[i][j] = Nodes[NodeIds[i]]->Position[j];
		}
	}
}

void 	ShapeBase::setReferencePositionMatrix(){
	const int n = nNodes;
	const int dim = nDim;
	ReferenceShape -> Positions = new double*[n];
	for (int i = 0; i<nNodes; ++i){
		ReferenceShape -> Positions[i] = new double[dim];
		for (int j = 0; j<dim; ++j){
			ReferenceShape -> Positions[i][j] = Positions[i][j];
		}
	}
}

void 	ShapeBase::updateShapeFromSave(ifstream& file){
	updateNodeIdsFromSave(file);
	updateReferencePositionMatrixFromSave(file);
}

void 	ShapeBase::updateNodeIdsFromSave(ifstream& file){
	for (int i = 0; i<nNodes; ++i){
		int savedId;
		file >> savedId;
		NodeIds[i] = savedId;
	}
}

void 	ShapeBase::updateReferencePositionMatrixFromSave(ifstream& file){
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			double savedPos;
			file >> savedPos;
			ReferenceShape -> Positions[i][j] = savedPos;
		}
	}
}

void 	ShapeBase::displayPositions(){
	for (int i=0; i<nNodes;++i){
		for (int j =0; j<nDim; ++j){
			cout<<Positions[i][j]<<"  ";
		}
		cout<<endl;
	}
}

int*	ShapeBase::getIdentifierColour(){
	return IdentifierColour;
}

void 	ShapeBase::getStrain(int type, float &StrainMag){
	updateTissueCoordStrain();
	StrainMag = 0.0;
	if (type == 0){
		//this is the average strain
		for (int i=0; i<3; ++i){
			StrainMag += ( StrainTissueMat(i,i) ) ;
		}
		StrainMag /= 3;
	}
	else if (type == 1){
		StrainMag = ( StrainTissueMat(0,0) );
	}
	else if (type == 2){
		StrainMag = ( StrainTissueMat(1,1) );
	}
	else if (type == 3){
		StrainMag = ( StrainTissueMat(2,2) );
	}
	else{
		return;
	}
}

void 	ShapeBase::getPlasticStrain(int type, float &StrainMag){
	StrainMag = 0.0;
	if (type == 0){
		for (int i=0; i<3; ++i){
			StrainMag += CurrPlasticStrainsInTissueCoordsMat(i,i);
		}
		StrainMag /= 3;
	}
	else if (type == 1){
		StrainMag = CurrPlasticStrainsInTissueCoordsMat(0,0);
	}
	else if (type == 2){
		StrainMag = CurrPlasticStrainsInTissueCoordsMat(1,1);
	}
	else if (type == 3){
		StrainMag = CurrPlasticStrainsInTissueCoordsMat(2,2);
	}
	else{
		return;
	}
}

void 	ShapeBase::getNodeBasedPysProp(int type, int NodeNo, vector<Node*>& Nodes, float& PysPropMag){
	PysPropMag = 0.0;
	if (type == 0){
		PysPropMag = Nodes[NodeIds[NodeNo]] -> Viscosity;
	}
}

void 	ShapeBase::getPysProp(int type, float &PysPropMag){
	PysPropMag = 0.0;
	if (type ==1){
		PysPropMag = getYoungModulus();
	}
	else if (type == 2 ){
		PysPropMag = getPoissonRatio();
	}
	else if (type ==3){
		double* growth;
		growth = getGrowthRate();
		for (int i =0 ; i< nDim ; ++i){
			PysPropMag += growth[i];
		}
		PysPropMag /= nDim;
	}
	else if (type ==4){
		double* shapechange;
		shapechange = getShapeChangeRate();
		PysPropMag = shapechange[2];
	}
}

void 	ShapeBase::displayIdentifierColour(){
	cout <<" IdentifierColour:  "<<IdentifierColour[0]<<" "<<IdentifierColour[1]<<" "<<IdentifierColour[2]<<endl;
}

void 	ShapeBase::resetCurrStepGrowthData(){
	for (int i=0;i<3;++i){
		CurrGrowthStrainAddition[i]  = 0.0;
		PlasticStrainsToAddInGrowthAxes[i]  = 0.0;
	}
	CurrGrowthStrainsUpToDate = false;
	IsGrowing = false;
}
void 	ShapeBase::resetCurrStepShapeChangeData(){
	for (int i=0;i<3;++i){
		CurrShapeChangeToAdd[i] = 0.0;
	}
	CurrShapeChangeStrainsUpToDate = false;
	IsChangingShape = false;
}

void 	ShapeBase::updateGrowthToAdd(double* growthscale){
	IsGrowing = true;
	for (int i=0;i<3;++i){
			CurrGrowthStrainAddition[i]  = CurrGrowthStrainAddition[i] + growthscale[i];
	}
}

void 	ShapeBase::growShape(){
	// The growth scale is the growth of this element should feel,
	// on the coordinates of the tissue, on Dorsal-Ventral, Anterior-Posterior, and Apical-Basal axes.
	// I need to get the orientation of this tissue coordinate system first.
	// This coordinate system, and all associated rotation matrices wiill change only when the
	// reference prism rotates, and it could have been updated in shape change functions up till this point.
	// There fore, I will re-calculate only if necessary
	if (!TissueCoordinateSystemUpToDate){
		calculateTissueCoordinateSystem();
		//Now I have the tissue coordinate system, I need to calculate the rotation matrix to rotate
		//the coordinate system of the reference prism to tissue coordinates
		calculateRotationMatrixReferenceToTissue();
	}
	//Now I have the rotation matrix and its transpose, I can rotate the strains:
	if (!CurrGrowthStrainsUpToDate){
		calculateCurrGrowthStrainsInTissueCoords();
	}
	updateGrowthStrainInTissueCoords(CurrGrowthStrainAddition);
}

void 	ShapeBase::changeShape(double shapechangescale, int axis){
	IsChangingShape = true;
	int compansatingaxes[2];
	if (axis == 0){
		compansatingaxes[0] = 1;
		compansatingaxes[1] = 2;
	}
	else if (axis == 1){
		compansatingaxes[0] = 0;
		compansatingaxes[1] = 2;
	}
	else if (axis == 2){
		compansatingaxes[0] = 0;
		compansatingaxes[1] = 1;
	}
	// I need to calculate the shape change in the coordinate system of the tissue,
	// This is why I need to have the rotation matrices between the
	// tissue coordinate system, local coordinate system and world coordinate system.
	// I will calculate these coordinate systems and corresponding rotation matrices]
	// ONLY if they are not up to date.
	// They will not be up-to date if the rotation if the reference element has changed
	// since last calculation.
	if (!TissueCoordinateSystemUpToDate){
		// I need to get the orientation of the tissue coordinate system first.
		calculateTissueCoordinateSystem();
		// Now I have the tissue coordinate system, I need to calculate the rotation matrix to rotate
		// the coordinate system of the reference prism to tissue coordinate system
		calculateRotationMatrixReferenceToTissue();
	}
	//Now I have the matrices necessary to calculate the shape changes, I need to rotate the shaoe change
	// that is already on the prism, to the tissue coordinate system. Since shape change function will be called
	// as many times on the element as there are active shape change inputs on its vicinity, I do not need to do this
	// rotation over and over again. It is different for growth changes, as I do all the update at once, and I do not
	// need such book-keeping.
	// CurrShapeChangeToAdd and the flag CurrShapeChangeStrainsUpToDate are reset at the beginnig of each time step, in function
	// resetCurrStepShapeChangeData
	if (!CurrShapeChangeStrainsUpToDate){
		calculateCurrShapeChangeStrainsInTissueCoords();
	}
	float effect =  (1.0 + CurrShapeChangeStrainsInTissueCoordsMat(axis,axis)) * shapechangescale;
	float compansation = -0.5 * effect;
	CurrShapeChangeToAdd[axis] += effect;
	CurrShapeChangeToAdd[compansatingaxes[0]] += compansation;
	CurrShapeChangeToAdd[compansatingaxes[1]] += compansation;
}

void ShapeBase::calculatePlasticStrain(){
	//If the element is growing or changing shape, I need to do that update first,
	//This also means the current strains on tissue coordinates will be up-to-date
	if (IsGrowing || IsChangingShape){
		if (IsGrowing){
			growShape();
		}
		if (IsChangingShape){
			//Here I need to update shape change
			updateShapeChangeStrainInTissueCoords();
		}
	}
	else {
		//The tissue is not changing its plastic deformation this step, but it may have rotate, and the
		// strains may not be correct any more
		if ( ( !CurrGrowthStrainsUpToDate && GrewInThePast ) || ( !CurrShapeChangeStrainsUpToDate && ChangedShapeInThePast ) ){
			if (!TissueCoordinateSystemUpToDate){
				calculateTissueCoordinateSystem();
				//Now I have the tissue coordinate system, I need to calculate the rotation matrix to rotate
				//the coordinate system of the reference prism to tissue coordinates
				calculateRotationMatrixReferenceToTissue();
			}
			if (!CurrGrowthStrainsUpToDate){
				calculateCurrGrowthStrainsInTissueCoords();
			}
			if (!CurrShapeChangeStrainsUpToDate){
				calculateCurrShapeChangeStrainsInTissueCoords();
			}
		}
	}
	//now sum up all the plastic strains
	updatePlasticStrainInTissueCoords();
	//Now I have the growth strain in growth axes, I need to convert it to world coordinates:
	//cout<<"entering updateGrowthStainInWorldAxes"<<endl;
	updatePlasticStainInWorldCoords();
	//cout<<"entering updateLocalPlasticStrain"<<endl;
	if (IsGrowing || IsChangingShape ){
		//The plastic strains on local coordinate system will only be affected if there is a plastic change on the element,
		//rotational changes will not affect the local coordinates, the local is on the reference shape frame in the first place.
		updateLocalPlasticStrains();
	}
	//cout<<"finished"<<endl;
}

void 	ShapeBase::calculateCurrGrowthStrainsInTissueCoords(){
	using namespace boost::numeric::ublas;
	matrix<double> tmpMat1(3,3);
	axpy_prod(RefToGrowthRotMat,LocalGrowthStrainsMat,tmpMat1);
	axpy_prod(tmpMat1,RefToGrowthRotMatT,CurrGrowthStrainsInTissueCoordsMat);
	CurrGrowthStrainsUpToDate = true;
}

void 	ShapeBase::calculateCurrShapeChangeStrainsInTissueCoords(){
	using namespace boost::numeric::ublas;
	matrix<double> tmpMat1(3,3);
	axpy_prod(RefToGrowthRotMat,LocalShapeChangeStrainsMat,tmpMat1);
	axpy_prod(tmpMat1,RefToGrowthRotMatT,CurrShapeChangeStrainsInTissueCoordsMat);
	CurrShapeChangeStrainsUpToDate = true;
}

void 	ShapeBase::updateGrowthStrainInTissueCoords(double* strainsToAdd){
	//Now I have the current strains defining the size of the element in gorwth axis coordinates
	//I can grow the system, with respect to its current size now (10% growth will be 10% of current size, cumulative interest)
	//displayMatrix(CurrPlasticStrainsInTissueCoordsMat,"CurrPlasticStrainsInTissueCoordsMat");
	CurrGrowthStrainsInTissueCoordsMat(0,0) = ( (1.0 + CurrGrowthStrainsInTissueCoordsMat(0,0)) * (1.0 + strainsToAdd[0]) ) - 1.0;
	CurrGrowthStrainsInTissueCoordsMat(1,1) = ( (1.0 + CurrGrowthStrainsInTissueCoordsMat(1,1)) * (1.0 + strainsToAdd[1]) ) - 1.0;
	CurrGrowthStrainsInTissueCoordsMat(2,2) = ( (1.0 + CurrGrowthStrainsInTissueCoordsMat(2,2)) * (1.0 + strainsToAdd[2]) ) - 1.0;
	//displayMatrix(CurrGrowthStrainsInTissueCoordsMat,"CurrGrowthStrainsInTissueCoordsMat");
}

void 	ShapeBase::updateShapeChangeStrainInTissueCoords(){
	//Now I have the current strains defining the size of the element in gorwth axis coordinates
	//I can grow the system, with respect to its current size now (10% growth will be 10% of current size, cumulative interest)
	//displayMatrix(CurrPlasticStrainsInTissueCoordsMat,"CurrPlasticStrainsInTissueCoordsMat");
	if (!CurrShapeChangeStrainsUpToDate){
		calculateCurrShapeChangeStrainsInTissueCoords();
	}
	CurrShapeChangeStrainsInTissueCoordsMat(0,0) += CurrShapeChangeToAdd[0];
	CurrShapeChangeStrainsInTissueCoordsMat(1,1) += CurrShapeChangeToAdd[1];
	CurrShapeChangeStrainsInTissueCoordsMat(2,2) += CurrShapeChangeToAdd[2];
	//displayMatrix(CurrShapeChangeStrainsInTissueCoordsMat,"CurrShapeChangeStrainsInTissueCoordsMat");
}

void 	ShapeBase::updatePlasticStrainInTissueCoords(){
	//This should be new growth strain in growth axes, not plastic strain to add
	CurrPlasticStrainsInTissueCoordsMat = CurrGrowthStrainsInTissueCoordsMat + CurrShapeChangeStrainsInTissueCoordsMat;
}

void 	ShapeBase::updateLocalPlasticStrains(){
	boost::numeric::ublas::matrix<double> tmpMat1(3,3);
	boost::numeric::ublas::matrix<double> tmpMat2(3,3);
	//	if I am in this function, at least on of IsGrowing or IsChangingShape is true, then I need to update
	//	total plastic strain regardless of details.
	axpy_prod(RefToGrowthRotMatT,CurrPlasticStrainsInTissueCoordsMat,tmpMat1);
	axpy_prod(tmpMat1,RefToGrowthRotMat,LocalPlasticStrainsMat);
	if (IsGrowing){
		axpy_prod(RefToGrowthRotMatT,CurrGrowthStrainsInTissueCoordsMat,tmpMat1);
		axpy_prod(tmpMat1,RefToGrowthRotMat,LocalGrowthStrainsMat);
	}
	if (IsChangingShape){
		axpy_prod(RefToGrowthRotMatT,CurrShapeChangeStrainsInTissueCoordsMat,tmpMat1);
		axpy_prod(tmpMat1,RefToGrowthRotMat,LocalShapeChangeStrainsMat);
	}
}

void 	ShapeBase::updateTissueCoordStrain(){
	boost::numeric::ublas::matrix<double> GrowthToWorldRotMatT(3,3);
	boost::numeric::ublas::matrix<double> tmpMat1(3,3);
	boost::numeric::ublas::matrix<double> StrainMat(3,3);
	StrainMat(0,0) = Strain(0);
	StrainMat(1,1) = Strain(1);
	StrainMat(2,2) = Strain(2);
	StrainMat(1,0) = Strain(3);
	StrainMat(1,2) = Strain(4);
	StrainMat(2,0) = Strain(5);
	StrainMat(0,1) = Strain(3);
	StrainMat(2,1) = Strain(4);
	StrainMat(0,2) = Strain(5);
	GrowthToWorldRotMatT = trans(GrowthToWorldRotMat);
	axpy_prod(GrowthToWorldRotMatT,StrainMat,tmpMat1);
	axpy_prod(tmpMat1,GrowthToWorldRotMat,StrainTissueMat);

}

void 	ShapeBase::updatePlasticStainInWorldCoords(){
	boost::numeric::ublas::matrix<double> tmpMat1(3,3);
	boost::numeric::ublas::matrix<double> tmpMat2(3,3);
	axpy_prod(GrowthToWorldRotMat,CurrPlasticStrainsInTissueCoordsMat,tmpMat1);
	boost::numeric::ublas::matrix<double> GrowthToWorldRotMatT(3,3);
	GrowthToWorldRotMatT = trans(GrowthToWorldRotMat);
	axpy_prod(tmpMat1,GrowthToWorldRotMatT,tmpMat2);
	PlasticStrain(0)= tmpMat2(0,0);
	PlasticStrain(1)= tmpMat2(1,1);
	PlasticStrain(2)= tmpMat2(2,2);
	PlasticStrain(3)= tmpMat2(1,0);
	PlasticStrain(4)= tmpMat2(1,2);
	PlasticStrain(5)= tmpMat2(2,0);
}

void ShapeBase::calculateTissueCoordinateSystem(){
	//I assume the orientation of the tissue stays as the dorsal-ventral axis is aligned with x = {1,0,0} and
	//anterior-posterior axis is aligned with y = {0,1,0}. I need to a coordinate system,
	//to align the z axis with the current apicobasal axis.
	//The current apical-basal axis is the z axis of the reference element.
	double* v = new double[3];
	calculateZVecForGrowhtAlignment(v);
	double* u = new double[3];
	u[0]=0.0;
	u[1]=0.0;
	u[2]=1.0;

	double c, s;
	calculateRotationAngleSinCos(u,v,c,s);
	double *rotAx;
	rotAx = new double[3];
	double *rotMat;
	rotMat = new double[9]; //matrix is written in one row
	calculateRotationAxis(u,v,rotAx);
	constructRotationMatrix(c,s,rotAx,rotMat);
	updateRotationMatrixTissueToWorld(rotMat);
	rotateWorldsCoordinatesByRotationMatrix(TissueCoordinateSystem,rotMat);
	//cout<<"TissueCoordinateSystem:"<<endl;
	//cout<<TissueCoordinateSystem[0]<<" 	"<<TissueCoordinateSystem[1]<<" 	"<<TissueCoordinateSystem[2]<<endl;
	//cout<<TissueCoordinateSystem[3]<<" 	"<<TissueCoordinateSystem[4]<<" 	"<<TissueCoordinateSystem[5]<<endl;
	//cout<<TissueCoordinateSystem[6]<<" 	"<<TissueCoordinateSystem[7]<<" 	"<<TissueCoordinateSystem[8]<<endl;
	delete[] u;
	delete[] v;
	delete[] rotAx;
	delete[] rotMat;
}

void ShapeBase::updateRotationMatrixTissueToWorld(double* rotMat){
		//this is the transpose of the rotation matrix I am using to rotate the world to growth axes
		GrowthToWorldRotMat(0,0)=rotMat[0];
		GrowthToWorldRotMat(1,0)=rotMat[1];
		GrowthToWorldRotMat(2,0)=rotMat[2];
		GrowthToWorldRotMat(0,1)=rotMat[3];
		GrowthToWorldRotMat(1,1)=rotMat[4];
		GrowthToWorldRotMat(2,1)=rotMat[5];
		GrowthToWorldRotMat(0,2)=rotMat[6];
		GrowthToWorldRotMat(1,2)=rotMat[7];
		GrowthToWorldRotMat(2,2)=rotMat[8];
}

void ShapeBase::calculateRotationMatrixReferenceToTissue(){
	//Now I need the rotation matrix to rotate the strains on growth coordinate system,
	//to strains in reference shape coordinate system;
	//The z axes are already aligned.
	//I will define the reference shape coordinate system as x-axis as the axis from node 0 to 1 for a prism
	//This selection is arbitrary, as long as it is consistent, I will be fine.
	double* u = new double[3];
	calculateXVecForGrowhtAlignment(u);
	double* v = new double[3];
	v[0]=TissueCoordinateSystem[0];
	v[1]=TissueCoordinateSystem[1];
	v[2]=TissueCoordinateSystem[2];
	double c, s;
	calculateRotationAngleSinCos(u,v,c,s);
	double *rotAx;
	rotAx = new double[3];
	double *rotMat;
	rotMat = new double[9]; //matrix is written in one row
	calculateRotationAxis(u,v,rotAx);
	constructRotationMatrix(c,s,rotAx,rotMat);
	RefToGrowthRotMat(0,0)=rotMat[0];
	RefToGrowthRotMat(0,1)=rotMat[1];
	RefToGrowthRotMat(0,2)=rotMat[2];
	RefToGrowthRotMat(1,0)=rotMat[3];
	RefToGrowthRotMat(1,1)=rotMat[4];
	RefToGrowthRotMat(1,2)=rotMat[5];
	RefToGrowthRotMat(2,0)=rotMat[6];
	RefToGrowthRotMat(2,1)=rotMat[7];
	RefToGrowthRotMat(2,2)=rotMat[8];
	RefToGrowthRotMatT = trans(RefToGrowthRotMat);
	delete[] u;
	delete[] v;
	delete[] rotAx;
	delete[] rotMat;

	//ReferenceShape->CurrAlignmentSide;
}

void ShapeBase::rotateWorldsCoordinatesByRotationMatrix(double* NewCoordinates, double *rotMat){
	double* u;
	u = new double[3];
	u[0]=1.0;
	u[1]=0.0;
	u[2]=0.0;
	rotateVectorByRotationMatrix(u,rotMat);
	NewCoordinates[0] = u[0];
	NewCoordinates[1] = u[1];
	NewCoordinates[2] = u[2];
	u[0]=0.0;
	u[1]=1.0;
	u[2]=0.0;
	rotateVectorByRotationMatrix(u,rotMat);
	NewCoordinates[3] = u[0];
	NewCoordinates[4] = u[1];
	NewCoordinates[5] = u[2];
	u[0]=0.0;
	u[1]=0.0;
	u[2]=1.0;
	rotateVectorByRotationMatrix(u,rotMat);
	NewCoordinates[6] = u[0];
	NewCoordinates[7] = u[1];
	NewCoordinates[8] = u[2];
	delete[] u;
}

void 	ShapeBase::alignReference(){
	//cout<<"aligning reference:"<<endl;

	updateAlignmentTurn();
	updateReferenceShapeBaseFromBuffer();
	calculateNormals();
	double *v,*u;
	v = new double[3];
	u = new double[3];
	for (int i=0;i<nDim; ++i){
		v[i] = CurrentNormal[i];
		u[i] = ReferenceShape->CurrentNormal[i];
	}
	double c, s;
	calculateRotationAngleSinCos(u,v,c,s);
	double *rotAx;
	rotAx = new double[3];
	double *rotMat;
	rotMat = new double[9]; //matrix is written in one row
	if (c<0.9998){ //only rotate if the vectors are more than 1 degree apart
		updatedReference = true;
		TissueCoordinateSystemUpToDate = false;
		CurrShapeChangeStrainsUpToDate = false;
		CurrGrowthStrainsUpToDate = false;
		//cout<<"Aligning the plane, angle big enough - cos: "<<c<<" sin: "<<s<<endl;
		calculateRotationAxis(u,v,rotAx);
		constructRotationMatrix(c,s,rotAx,rotMat);
		//double centre[3];
		for (int i=0; i<nNodes; ++i){
			u[0] = ReferenceShape->Positions[i][0];
			u[1] = ReferenceShape->Positions[i][1];
			u[2] = ReferenceShape->Positions[i][2];
			rotateVectorByRotationMatrix(u,rotMat);
			ReferenceShape->Positions[i][0] = u[0];
			ReferenceShape->Positions[i][1] = u[1];
			ReferenceShape->Positions[i][2] = u[2];
		}
		//Aligned the planes, now align the sides:
	}
	//else{ cout<<"skipping plane alignment, degree is too small: cosine: "<<c<<" sine: "<<s<<endl;}
	double* RefSide = new double[3];
	double* ShapeSide;
	ShapeSide = new double[3];

	getCurrentAlignmentSides(RefSide, ShapeSide);
	calculateRotationAngleSinCos(RefSide,ShapeSide,c,s);
	if (c<0.9998){  //only rotate if the vectors are more than 1 degree apart
		updatedReference = true;
		TissueCoordinateSystemUpToDate = false;
		CurrShapeChangeStrainsUpToDate = false;
		CurrGrowthStrainsUpToDate = false;
		//cout<<"Aligning the side, angle big enough - cos: "<<c<<" sin: "<<s<<endl;
		calculateRotationAxis(RefSide,ShapeSide,rotAx);
		constructRotationMatrix(c,s,rotAx,rotMat);
		for (int i=0; i<nNodes; ++i){
			u[0] = ReferenceShape->Positions[i][0];
			u[1] = ReferenceShape->Positions[i][1];
			u[2] = ReferenceShape->Positions[i][2];
			rotateVectorByRotationMatrix(u,rotMat);
			ReferenceShape->Positions[i][0] = u[0];
			ReferenceShape->Positions[i][1] = u[1];
			ReferenceShape->Positions[i][2] = u[2];
		}
		//Now they are aligned, but I do not know if they face the same direction, so I need to check that:
		/*
		bool facecorrection = areSidesFacingSameDirection(RefSide, ShapeSide);
		if (!facecorrection){
			//face is in the wrong direction, I need to rotate the element a further 180 degrees
			constructRotationMatrix(-1.0,0.0,rotAx,rotMat);
			for (int i=0; i<nNodes; ++i){
				u[0] = ReferenceShape->Positions[i][0];
				u[1] = ReferenceShape->Positions[i][1];
				u[2] = ReferenceShape->Positions[i][2];
				rotateVectorByRotationMatrix(u,rotMat);
				ReferenceShape->Positions[i][0] = u[0];
				ReferenceShape->Positions[i][1] = u[1];
				ReferenceShape->Positions[i][2] = u[2];
			}
			cout<<"Reference positions after face correction: "<<endl;
			for (int i = 0; i<nNodes; ++i){
				for (int j = 0; j<nDim; ++j){
					cout<<ReferenceShape->Positions[i][j]<<" ";
				}
				cout<<endl;
			}
			cout<<endl;

		}
		*/
	}
	//else{ cout<<"skipping side alignment, degree is too small: cosine: "<<c<<" sine: "<<s<<endl;}
	//aligning the position to the curr shape centre:
	double translocation[3] = {0.0,0.0,0.0};
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			translocation[j] +=  Positions[i][j] - ReferenceShape ->Positions[i][j];
		}
	}
	for (int j = 0; j<nDim; ++j){
		translocation[j] /= nNodes;
	}
	//translocation[0] -= 5.0;
	for (int i = 0; i<nNodes; ++i){
			for (int j = 0; j<nDim; ++j){
				ReferenceShape->Positions[i][j] +=translocation[j];
			}
	}
	delete[] u;
	delete[] v;
	delete[] rotAx;
	delete[] rotMat;
	delete[] RefSide;
	delete[] ShapeSide;
	//cout<<"finalised aligning reference, update reference? "<<updatedReference<<endl;
}

bool	ShapeBase::areSidesFacingSameDirection(double* RefSide, double* ShapeSide){
	double* RefFace;
	RefFace = new double[3];
	double* ShapeFace;
	ShapeFace = new double[3];
	getCurrentAlignmentFaces(RefSide, ShapeSide, RefFace, ShapeFace);
	double dotp = dotProduct3D(RefFace,ShapeFace);
	if ( dotp < 0){
		return false;
	}
	else{
		return true;
	}
	delete[] RefFace;
	delete[] ShapeFace;
}

void	ShapeBase::calculateRotationAngleSinCos(double* u, double* v, double& c, double& s){
	//aligning u onto v:
	c = dotProduct3D(u,v);
	if (c > 1.0){
		c = 1.0;
		s = 0.0;
	}
	else if( c<-1.0){
		c = -1.0;
		s = 0.0;
	}
	else{
		double tet = acos(c);
		s = sin(tet);
	}
}

void	ShapeBase::calculateRotationAxis(double* u, double* v,double* rotAx){
	//aligning u onto v:
	crossProduct3D(u,v,rotAx);
	normaliseVector3D(rotAx);
}

void	ShapeBase::constructRotationMatrix(double c, double s, double* rotAx, double* rotMat){
	//cout<<" Rotation axis: "<<rotAx[0]<<" "<<rotAx[1]<<" "<<rotAx[2]<<endl;

	rotMat[0] = c + rotAx[0]*rotAx[0]*(1 - c);
	rotMat[1] = rotAx[0]*rotAx[1]*(1 - c) - rotAx[2]*s;
	rotMat[2] = rotAx[0]*rotAx[2]*(1 - c) + rotAx[1]*s;

	rotMat[3] = rotAx[1]*rotAx[0]*(1 - c) + rotAx[2]*s;
	rotMat[4] = c + rotAx[1]*rotAx[1]*(1 - c);
	rotMat[5] = rotAx[1]*rotAx[2]*(1 - c) - rotAx[0]*s;

	rotMat[6] = rotAx[2]*rotAx[0]*(1 - c) - rotAx[1]*s;
	rotMat[7] = rotAx[2]*rotAx[1]*(1 - c) + rotAx[0]*s;
	rotMat[8] = c + rotAx[2]*rotAx[2]*(1 - c);

	/*cout<<"Rotation Matrix: "<<endl;
	cout<<rotMat[0]<<" "<<rotMat[1]<<" "<<rotMat[2]<<endl;
	cout<<rotMat[3]<<" "<<rotMat[4]<<" "<<rotMat[5]<<endl;
	cout<<rotMat[6]<<" "<<rotMat[7]<<" "<<rotMat[8]<<endl;*/
}

void	ShapeBase::rotateVectorByRotationMatrix(double* u,double* rotMat){
	double x = rotMat[0]*u[0]+rotMat[1]*u[1]+rotMat[2]*u[2];
	double y = rotMat[3]*u[0]+rotMat[4]*u[1]+rotMat[5]*u[2];
	double z = rotMat[6]*u[0]+rotMat[7]*u[1]+rotMat[8]*u[2];
	//cout<<"before rotation: "<<u[0]<<" "<<u[1]<<" "<<u[2]<<endl;
	u[0] = x;
	u[1] = y;
	u[2] = z;
	//cout<<"after rotation: "<<u[0]<<" "<<u[1]<<" "<<u[2]<<endl;
}

void	ShapeBase::calculateForces(int RKid, double **SystemForces, vector <Node*>& Nodes){
	//cout<<"calculating forces"<<endl;
	const int nMult = nNodes*nDim;

	using namespace boost::numeric::ublas;
	boost::numeric::ublas::vector<double> displacement(nMult);
	int counter = 0;
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			displacement(counter) = Positions[i][j]-ReferenceShape->Positions[i][j];
			counter++;
		}
	}

	Forces = zero_vector<double>(nMult);
	boost::numeric::ublas::vector<double> PlasticStrainForces = zero_vector<double>(nMult);
	//displayMatrix(BE,"BE");

	//cout<<"multiplying to get forces"<<endl;
	boost::numeric::ublas::axpy_prod(k,displacement,Forces);
	//cout<<"multiplying to get strain"<<endl;
	boost::numeric::ublas::axpy_prod(B,displacement,Strain);
	//cout<<"multiplying to get the contribution of the forces"<<endl;
	//displayMatrix(GrowthStrain,"GrowthStrain");
	//displayMatrix(ShapeChangeStrain,"ShapeChangeStrain");
	//displayMatrix(PlasticStrain,"PlasticStrain");
	//displayMatrix(Strain,"Strain");
	boost::numeric::ublas::axpy_prod(BE,PlasticStrain,PlasticStrainForces);
	//cout<<"getting the net forces"<<endl;
	Forces = Forces - PlasticStrainForces;
	//displayMatrix(Forces,"Forces");
	//displayMatrix(PlasticStrainForces,"PlasticStrainForces");
	counter = 0;
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			if (!Nodes[NodeIds[i]]->FixedPos[j]){
				SystemForces[NodeIds[i]][j] = SystemForces[NodeIds[i]][j] - Forces(counter);
			}
			counter++;
		}
	}
	/*
	cout<<"Element: "<<Id<<endl;
	cout<<"positions: "<<endl;
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			cout<<Positions[i][j]<<" ";
		}
		cout<<endl;
	}
	cout<<"Reference positions: "<<endl;
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
			cout<<ReferenceShape->Positions[i][j]<<" ";
		}
		cout<<endl;
	}
	displayMatrix(displacement,"displacement");
	displayMatrix(Forces,"Forces");
	cout<<"SystemForces:"<<endl;
	int nSysNodes = Nodes.size();
	for (int i=0;i<nSysNodes;++i){
		for (int j=0;j<3;++j){
			cout<<SystemForces[i][j]<<" ";
		}
		cout<<endl;
	}
	cout<<endl;*/
	//cout<<"finalised calculating forces"<<endl;
}

void	ShapeBase::updatePositions(vector<Node*>& Nodes){
	for (int i = 0; i<nNodes; ++i){
		for (int j = 0; j<nDim; ++j){
				Positions[i][j] = Nodes[NodeIds[i]]->Position[j];
		}
	}
}

void 	ShapeBase::setGrowthRate(double x, double y, double z){
	GrowthRate[0] = x;
	GrowthRate[1] = y;
	GrowthRate[2] = z;
}

void 	ShapeBase::setShapeChangeRate(double x, double y, double z){
	ShapeChangeRate[0] = x;
	ShapeChangeRate[1] = y;
	ShapeChangeRate[2] = z;
}

void 	ShapeBase::updateGrowthRate(double scalex, double scaley, double scalez){
	//This value is stored as per hour:
	GrowthRate[0] += scalex;
	GrowthRate[1] += scaley;
	GrowthRate[2] += scalez;
}

void 	ShapeBase::updateShapeChangeRate(double scale, int axis){
	int compansatingaxes[2];
	if (axis == 0){
		compansatingaxes[0] = 1;
		compansatingaxes[1] = 2;
	}
	else if (axis == 1){
		compansatingaxes[0] = 0;
		compansatingaxes[1] = 2;
	}
	else if (axis == 2){
		compansatingaxes[0] = 0;
		compansatingaxes[1] = 1;
	}
	float effect = ( 1.0 + ShapeChangeRate[axis] ) * scale;
	float compansation = -0.5 * effect;
	ShapeChangeRate[axis] += effect;
	ShapeChangeRate[compansatingaxes[0]] += compansation;
	ShapeChangeRate[compansatingaxes[2]] += compansation;
}

bool 	ShapeBase::InvertMatrix(boost::numeric::ublas::matrix<double>& input, boost::numeric::ublas::matrix<double>& inverse, double& det){
	//Matrix inversion routine.
	//Uses lu_factorize and lu_substitute in uBLAS to invert a matrix
	using namespace boost::numeric::ublas;
	typedef permutation_matrix<std::size_t> pmatrix;

	// create a working copy of the input
	matrix<double> A(input);

	// create a permutation matrix for the LU-factorization
	pmatrix pm(A.size1());

	// perform LU-factorization
	int res = lu_factorize(A, pm);
	if (res != 0)
		return false;

	det = 1.0;
	for(int i = 0; i < A.size1(); i++) {
		det *= A(i,i); // multiply by elements on diagonal
	    det = det * determinant_sign( pm );
	}
	// create identity matrix of "inverse"
	inverse.assign(identity_matrix<double> (A.size1()));

	// backsubstitute to get the inverse
	lu_substitute(A, pm, inverse);

	return true;
}

int 	ShapeBase::determinant_sign(boost::numeric::ublas::permutation_matrix<std::size_t>& pm)
{
    int pm_sign=1;
    std::size_t size = pm.size();
    for (std::size_t i = 0; i < size; ++i)
        if (i != pm(i))
            pm_sign *= -1.0; // swap_rows would swap a pair of rows here, so we change sign
    return pm_sign;
}

void	ShapeBase::crossProduct3D(double* u, double* v, double* cross){
	cross[0] = u[1]*v[2] - u[2]*v[1];
	cross[1] = u[2]*v[0] - u[0]*v[2];
	cross[2] = u[0]*v[1] - u[1]*v[0];
}

void	ShapeBase::normaliseVector3D(double* v){
	double mag2 = v[0]*v[0]+v[1]*v[1]+v[2]*v[2];
	if (fabs(mag2) > 1E-14 && fabs(mag2 - 1.0f) > 1E-14) {
		double mag = pow(mag2,0.5);
		v[0] /= mag;
		v[1] /= mag;
		v[2] /= mag;
	}
}

double 	ShapeBase::dotProduct3D(double* u, double* v){
	double dot = 0;
	dot = u[0]*v[0]+u[1]*v[1]+u[2]*v[2];
	return dot;
}

void 	ShapeBase::displayMatrix(boost::numeric::ublas::matrix<double>& mat, string matname){
	int m = mat.size1();
	int n = mat.size2();
	cout<<matname<<": "<<endl;

	for (int i =0; i<m; i++){
		for (int j =0; j<n; j++){
			cout.precision(4);
			cout.width(6);
			cout<<mat(i,j)<<" ";
		}
		cout<<endl;
	}
	cout<<endl;
}

void 	ShapeBase::displayMatrix(boost::numeric::ublas::matrix<int>& mat, string matname){
	int m = mat.size1();
	int n = mat.size2();
	cout<<matname<<": "<<endl;

	for (int i =0; i<m; i++){
		for (int j =0; j<n; j++){
			cout.precision(4);
			cout.width(6);
			cout<<mat(i,j)<<" ";
		}
		cout<<endl;
	}
	cout<<endl;
}

void	ShapeBase::displayMatrix(boost::numeric::ublas::vector<double>& vec, string matname){
	int m = vec.size();
	cout<<matname<<": "<<endl;
	for (int i =0; i<m; i++){
		cout.precision(4);
		cout.width(6);
		cout<<vec(i)<<" ";
	}
	cout<<endl;
}
